<!-- <!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Crisp Inputs in CSS3DRenderer</title>
<style>
  body {
    margin: 0;
    background: #111;
    overflow: hidden;
  }

  canvas {
    position: absolute;
    top: 0;
    left: 0;
    z-index: 0;
    pointer-events: none;
  }

  #cssRenderer {
    position: absolute;
    top: 0;
    left: 0;
    z-index: 2;
  }

  /* --- plane-wrapper --- */
  .plane-wrapper {
    display: grid;
    grid-template-columns: repeat(10, 1fr);
    grid-template-rows: repeat(12, 1fr);
    backface-visibility: hidden;
    transform-style: preserve-3d;
    will-change: transform;
    image-rendering: pixelated;
    -webkit-font-smoothing: none;
    -moz-osx-font-smoothing: grayscale;
  }

  /* --- input field --- */
  .inputPlane {
    width: 6px;
    height: 9px;
    padding: 0;
    margin: 0;
    font-size: 6px;
    line-height: 9px;
    text-align: center;
    font-family: monospace;
    border: none;
    color: #fff;
    background: transparent;
    pointer-events: auto;
    outline: none;

    /* âœ¨ í•µì‹¬: íë¦¼ ì œê±° */
    -webkit-font-smoothing: none !important;
    text-rendering: geometricPrecision;
    filter: none;
    transform: translate3d(0, 0, 0) scale(1.0001);
    backface-visibility: hidden;
  }

  /* í¬ì»¤ìŠ¤ ì‹œì—ë„ blur ì•ˆ ìƒê¹€ */
  .inputPlane:focus {
    background: transparent;
    border: none;
    outline: none;
    filter: none;
    transform: translate3d(0, 0, 0) scale(1.0001);
  }
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/"
  }
}
</script>
</head>

<body>
<script type="module">
import * as THREE from 'three';
import { CSS3DRenderer, CSS3DObject } from 'three/addons/renderers/CSS3DRenderer.js';

let scene, camera, webGLRenderer, cssRenderer, sphereGroup;
let rotationX = 0, rotationY = 0;
const speed = 0.02;
const keys = { ArrowUp:false, ArrowDown:false, ArrowLeft:false, ArrowRight:false };

init();
animate();

function init() {
  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 0, 0);

  webGLRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  webGLRenderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(webGLRenderer.domElement);

  cssRenderer = new CSS3DRenderer();
  cssRenderer.setSize(window.innerWidth, window.innerHeight);
  cssRenderer.domElement.id = "cssRenderer";
  document.body.appendChild(cssRenderer.domElement);

  sphereGroup = new THREE.Group();
  scene.add(sphereGroup);

  const radius = 150;
  const minPlaneSize = 80;
  const latitudes = Math.ceil(Math.PI * radius / minPlaneSize);
  const planeSize = Math.PI * radius / latitudes;

  let inputCount = 1;

  for (let i = 0; i <= latitudes; i++) {
    const theta = i * Math.PI / latitudes;
    const y = radius * Math.cos(theta);
    const r = radius * Math.sin(theta);
    const longitudes = r === 0 ? 1 : Math.ceil(2 * Math.PI * r / planeSize);

    for (let j = 0; j < longitudes; j++) {
      const phi = j * 2 * Math.PI / longitudes;
      const x = r * Math.cos(phi);
      const z = r * Math.sin(phi);

      // WebGL í‰ë©´
      const geometry = new THREE.PlaneGeometry(planeSize, planeSize);
      const material = new THREE.MeshBasicMaterial({ color: 0xff00ff, side: THREE.DoubleSide});
      // const material = new THREE.MeshBasicMaterial({ visible: false });
      const plane = new THREE.Mesh(geometry, material);
      plane.position.set(x, y, z);
      plane.lookAt(0, 0, 0);
      sphereGroup.add(plane);

      const div = document.createElement('div');
      div.className = 'plane-wrapper';
      div.style.width = planeSize + 'px';
      div.style.height = planeSize + 'px';

      const inputsPerPlane = 120;
      for (let k = 0; k < inputsPerPlane; k++) {
        const input = document.createElement('input');
        input.type = 'text';
        input.maxLength = 1;
        input.className = 'inputPlane';
        input.id = 'input' + (inputCount++);
        div.appendChild(input);
        if (input.id === 'input1') setTimeout(() => input.focus(), 300);
      }

      const object = new CSS3DObject(div);
      object.position.set(x, y, z);
      object.lookAt(0, 0, 0);
      sphereGroup.add(object);
    }
  }

  window.addEventListener('keydown', e => { if (keys.hasOwnProperty(e.key)) keys[e.key] = true; });
  window.addEventListener('keyup', e => { if (keys.hasOwnProperty(e.key)) keys[e.key] = false; });

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    webGLRenderer.setSize(window.innerWidth, window.innerHeight);
    cssRenderer.setSize(window.innerWidth, window.innerHeight);
  });
}

function animate() {
  requestAnimationFrame(animate);

  if (keys.ArrowUp) rotationX -= speed;
  if (keys.ArrowDown) rotationX += speed;
  if (keys.ArrowLeft) rotationY -= speed;
  if (keys.ArrowRight) rotationY += speed;

  sphereGroup.rotation.x = rotationX;
  sphereGroup.rotation.y = rotationY;

  webGLRenderer.render(scene, camera);
  cssRenderer.render(scene, camera);
}
</script>
</body>
</html> -->

<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Crisp Inputs in CSS3DRenderer</title>
<!-- css -->
<link rel="stylesheet" href="font.css">
<style>
  body {
    margin: 0;
    background: blue;
    /* background-image: url("img/sky_1.jpg"); */
    overflow: hidden;
  }

  canvas {
    position: absolute;
    top: 0;
    left: 0;
    z-index: 0;
    pointer-events: none;
  }

  #cssRenderer {
    position: absolute;
    top: 0;
    left: 0;
    z-index: 2;
  }

  /* --- plane-wrapper --- */
  .plane-wrapper {
    display: grid;
    /* grid-template-columns: repeat(10, 1fr);
    grid-template-rows: repeat(12, 1fr); */
    backface-visibility: hidden;
    transform-style: preserve-3d;
    will-change: transform;
    image-rendering: pixelated;
    -webkit-font-smoothing: none;
    -moz-osx-font-smoothing: grayscale;

    grid-auto-columns: 1fr; 
    grid-auto-rows: 1fr; 
    grid-template-columns: 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr; 
    grid-template-rows: 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr; 
    gap: 0px 0px; 
    grid-template-areas: 
      ". . . . . . . . ."
      ". . . . . . . . ."
      ". . . . . . . . ."
      ". . . . . . . . ."
      ". . . . . . . . ."
      ". . . . . . . . ."
      ". . . . . . . . ."
      ". . . . . . . . ."
      ". . . . . . . . ."
      ". . . . . . . . ."
      ". . . . . . . . ."
      ". . . . . . . . ."
      ". . . . . . . . ."
      ". . . . . . . . ."; 
    /* background: red; */
  }

  /* --- input field --- */
  .inputPlane {
    width: 100%;
    height: 100%;
    /* width: 6px;
    height: 9px; */
    padding: 0;
    margin: 0;
    font-size: 11px;
    line-height: 9px;
    text-align: center;
    font-family: FKGroteskMonoTrial-Regular;
    text-transform: uppercase;
    border: 1px solid white;
    border: none;
    color: gray;
    background: transparent;
    pointer-events: auto;
    outline: none;

    /* âœ¨ í•µì‹¬: íë¦¼ ì œê±° */
    -webkit-font-smoothing: none !important;
    text-rendering: geometricPrecision;
    filter: none;
    transform: translate3d(0, 0, 0) scale(1.0001);
    backface-visibility: hidden;
  }

  /* í¬ì»¤ìŠ¤ ì‹œì—ë„ blur ì•ˆ ìƒê¹€ */
  .inputPlane:focus {
    background: transparent;
    border: none;
    outline: none;
    filter: none;
    transform: translate3d(0, 0, 0) scale(1.0001);
  }

  .input-texted {
    position: relative;
    /* animation: float 3s ease-in-out infinite; */
    /* animation: float-3d 3s infinite ease-in-out alternate; */
  }

  @keyframes float {
      0% {
          transform: translateY(0);
      }

      50% {
          transform: translateY(-20px);
      }

      100% {
          transform: translateY(0);
      }
  }

  @keyframes float-3d {
    from {
      transform: translateZ(0) rotateX(0deg); /* Starting position and rotation */
    }
    to {
      transform: translateZ(20px) rotateX(10deg); /* Floating closer and tilting */
    }
  }


  #bg-video {
    position: fixed;
    top: 0; left: 0;
    width: 100vw;
    height: 100vh;
    object-fit: cover;
    z-index: -1;
  }
</style>


<script src="/socket.io/socket.io.js"></script>
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/"
  }
}
</script>
</head>

<body>
  <div style="position: fixed; top: 10px; left: 15px; width: 35%; z-index: 3;">
    <!-- <h1>Air-Drop</h1> -->
    <!-- <p>
      The internet is the air that grounds us. This shared, vast universe allows us to join, engage, and connect with each other. Here, in Airâ€“Drop, you are invited to leave a message or drawing as a gift for an unknown recipient. What you drop will drift through this space, float in the air, and eventually land in someoneâ€™s hands. Let your heart travel around the world! Though we never cross paths, we feel each other through your drops, breathing in the same air.
    </p> -->
  </div>

<script type="module">
  const socket = io();
  
  import * as THREE from 'three';
  import { CSS3DRenderer, CSS3DObject } from 'three/addons/renderers/CSS3DRenderer.js';
  import { FontLoader } from 'three/addons/loaders/FontLoader.js';
  import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
  import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';


  const loader = new FontLoader();
  let loadedFont = null;
  loader.load('font/FK Grotesk SemiMono Trial_Regular.json', (font) => {
    loadedFont = font;
    init();  // í°íŠ¸ê°€ ì¤€ë¹„ëœ í›„ ì´ˆê¸°í™” ì‹¤í–‰
    animate();
  });
  // let loadedFont = null;
  // loader.load('font/ReadyActiveTest-Light.json', (font) => {
  //   loadedFont = font;
  //   init();  // í°íŠ¸ê°€ ì¤€ë¹„ëœ í›„ ì´ˆê¸°í™” ì‹¤í–‰
  //   animate();
  // });
  // let loadedFont = null;
  // loader.load('font/Menlo_Regular.json', (font) => {
  //   loadedFont = font;
  //   init();  // í°íŠ¸ê°€ ì¤€ë¹„ëœ í›„ ì´ˆê¸°í™” ì‹¤í–‰
  //   animate();
  // });


  const gltfLoader = new GLTFLoader();
  let cloudNorth, cloudSouth;
  let scene, camera, webGLRenderer, cssRenderer, sphereGroup, backgroundMesh, texture, ctx, canvas;
  let rotationX=0, rotationY=0, speed=0.02;
  const keys = { ArrowUp:false, ArrowDown:false, ArrowLeft:false, ArrowRight:false };
  let allInputs = []; // âœ… ëª¨ë“  input ì¶”ì ìš© ë°°ì—´

  // ğŸŒ ì‹œê°„ëŒ€ë³„ ê·¸ë¼ë””ì–¸íŠ¸ íŒ”ë ˆíŠ¸
  const gradients = {
    dawn:   ['#1a237e', '#3949ab', '#81d4fa'], // ìƒˆë²½
    morning:['#81d4fa', '#fff176', '#ffb74d'], // ì•„ì¹¨
    // noon:   ['#64b5f6', '#4dd0e1', '#81c784'], // ì ì‹¬
    noon:['#81d4fa', '#fff176', '#ffb74d'], // ì ì‹¬
    evening:['#ff8a65', '#f06292', '#ba68c8'], // ì €ë…
    night:  ['#00afff', '#4ADBFF', '#ffffff']  // ë°¤
    // night:  ['#00afff', '#4ADBFF', '#ffffff']  // ë°¤
    // night:  ['#0d47a1', '#1a237e', '#000022']  // ë°¤
  };

  // ğŸ•’ ì „ì—­ ë³€ìˆ˜ëŠ” ë°˜ë“œì‹œ updateGradientë³´ë‹¤ ë¨¼ì € ì„ ì–¸
  let currentPalette = gradients[getTimeOfDay()];
  let targetPalette = currentPalette.slice(); // ë³µì‚¬
  let lastUpdate = 0;


  // init();
  // animate();

  // â° í˜„ì¬ ì‹œê°„ëŒ€ì— ë§ëŠ” ê·¸ë¼ë””ì–¸íŠ¸ ì„ íƒ
  function getTimeOfDay() {
    const hour = new Date().getHours();
    if (hour >= 4 && hour < 8)   return 'dawn';     // 4~7ì‹œ: ìƒˆë²½
    if (hour >= 8 && hour < 12)  return 'morning';  // 8~11ì‹œ: ì•„ì¹¨
    if (hour >= 12 && hour < 17) return 'noon';     // 12~16ì‹œ: ì ì‹¬
    if (hour >= 17 && hour < 21) return 'evening';  // 17~20ì‹œ: ì €ë…
    return 'night';                                 // 21~3ì‹œ: ë°¤
  }

  function hexToRgb(hex) {
    if (hex.startsWith('rgb')) {
      // ì´ë¯¸ rgb ë¬¸ìì—´ì¼ ê²½ìš° ê·¸ëŒ€ë¡œ íŒŒì‹±
      const [r, g, b] = hex.match(/\d+/g).map(Number);
      return { r, g, b };
    }

    // hex â†’ rgb ë³€í™˜
    const bigint = parseInt(hex.replace('#',''), 16);
    return {
      r: (bigint >> 16) & 255,
      g: (bigint >> 8) & 255,
      b: bigint & 255
    };
  }

  function blendColors(c1, c2, t) {
    const a = hexToRgb(c1);
    const b = hexToRgb(c2);

    const r = Math.round(a.r + (b.r - a.r) * t);
    const g = Math.round(a.g + (b.g - a.g) * t);
    const b2 = Math.round(a.b + (b.b - a.b) * t);

    return `rgb(${r},${g},${b2})`;
  }

  // ğŸ¨ ë°°ê²½ ê·¸ë¼ë””ì–¸íŠ¸ ì—…ë°ì´íŠ¸
  function updateGradient(time) {
    const now = getTimeOfDay();

    // 10ì´ˆë§ˆë‹¤ ì‹œê°„ëŒ€ ì²´í¬
    if (time - lastUpdate > 10000) {
      const newPalette = gradients[now];
      if (newPalette !== targetPalette) {
        targetPalette = newPalette;
      }
      lastUpdate = time;
    }

    // ìƒ‰ìƒ ë³´ê°„ (hex â†’ rgb â†’ ë³´ê°„ í›„ rgb)
    for (let i = 0; i < 3; i++) {
      currentPalette[i] = blendColors(currentPalette[i], targetPalette[i], 0.02);
    }

    const gradient = ctx.createLinearGradient(0, 0, 0, window.innerHeight);
    gradient.addColorStop(0, currentPalette[0]);
    gradient.addColorStop(0.5, currentPalette[1]);
    gradient.addColorStop(1, currentPalette[2]);

    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    texture.needsUpdate = true;
  }


// ----------------------
// ì´ˆê¸°í™” í•¨ìˆ˜
function init() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 0, 0);

  webGLRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  webGLRenderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(webGLRenderer.domElement);

  cssRenderer = new CSS3DRenderer();
  cssRenderer.setSize(window.innerWidth, window.innerHeight);
  cssRenderer.domElement.id = "cssRenderer";
  document.body.appendChild(cssRenderer.domElement);

  sphereGroup = new THREE.Group();
  scene.add(sphereGroup);


  // ğŸŒ„ ë°°ê²½ìš© Canvas
  canvas = document.createElement('canvas');
  const dpr = window.devicePixelRatio || 1;
  canvas.width = window.innerWidth * dpr;
  canvas.height = window.innerHeight * dpr;
  ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr); // ìº”ë²„ìŠ¤ ì „ì²´ ìŠ¤ì¼€ì¼ ë³´ì • (ê³ í•´ìƒë„ì—ì„œë„ ê¹¨ë—í•˜ê²Œ)

  texture = new THREE.CanvasTexture(canvas);
  texture.minFilter = THREE.LinearFilter;  // í”½ì…€í™” ë°©ì§€
  texture.magFilter = THREE.LinearFilter;  // í”½ì…€í™” ë°©ì§€
  texture.generateMipmaps = false;         // mipmap ë¹„í™œì„±í™” (ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ ì‹œ í•„ìˆ˜)
  texture.needsUpdate = true;

  // ğŸŒŒ ë°°ê²½ êµ¬ ìƒì„±
  const radius = 500;
  const geometry = new THREE.SphereGeometry(radius, 64, 64);
  const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.BackSide });
  backgroundMesh = new THREE.Mesh(geometry, material);
  sphereGroup.add(backgroundMesh);

  // -----------------------------
  // í´ë¼ìš°ë“œ ë¡œë”© (ë¶ê·¹)
  //   gltfLoader.load('img/cloud.glb', (gltf) => {
  //   cloudNorth = gltf.scene;
  //   cloudNorth.traverse((child) => {
  //     if (child.isMesh) {
  //       child.material = new THREE.MeshBasicMaterial({
  //         map: child.material.map,
  //         side: THREE.DoubleSide,
  //         transparent: true,
  //         opacity: 0.8,
  //         depthWrite: false,
  //         alphaTest: 0.5
  //       });
  //     }
  //   });
  //   cloudNorth.scale.set(100, 100, 100);
  //   cloudNorth.position.set(0, radius, 0);
  //   sphereGroup.add(cloudNorth);
  // });


  // í´ë¼ìš°ë“œ ë¡œë”© (ë‚¨ê·¹)
  gltfLoader.load('img/cloud.glb', (gltf) => {
    cloudSouth = gltf.scene;
    cloudSouth.traverse((child) => {
      if (child.isMesh) {
        child.material = new THREE.MeshBasicMaterial({
          map: child.material.map,
          side: THREE.DoubleSide,
          transparent: true,
          opacity: 0.8,
          depthWrite: false,
          alphaTest: 0.5
        });
      }
    });
    cloudSouth.scale.set(50, 50, 50);
    cloudSouth.position.set(0, -radius, 0);
    sphereGroup.add(cloudSouth);
  });




  // ğŸŒˆ----------------------------
  // ê²©ì ìƒì„±
  const latLines = 6, lonLines=16, lineThickness=1;
  // ê²©ì í¬ì¸íŠ¸ ì €ì¥
  const verticalLines=[], horizontalLines=[];

  const gridColor = 0xffffff;

  // Tube ìƒì„±ìš© í•¨ìˆ˜
  function createTubeFromPoints(points, radius = 1, radialSegments = 6) {
    class CustomCurve extends THREE.Curve {
      constructor(points){super();this.points=points;}
      getPoint(t) {
        const idx = t * (this.points.length - 1);
        const i = Math.floor(idx);
        const frac = idx - i;
        if (i >= this.points.length - 1) return this.points[this.points.length - 1];
        return new THREE.Vector3().lerpVectors(this.points[i], this.points[i + 1], frac);
      }
    }

    const curve = new CustomCurve(points);
    const geometry = new THREE.TubeGeometry(curve, points.length * 2, radius, radialSegments, false);
    const material = new THREE.MeshBasicMaterial({ color: gridColor });
    return new THREE.Mesh(geometry, material);
  }

  // ì„¸ë¡œì„ 
  for(let i=0;i<=lonLines;i++){
    const phi = (i/lonLines)*2*Math.PI;
    const points=[];
    for(let j=0;j<=latLines;j++){
      const theta=(j/latLines)*Math.PI;
      const x=500*Math.sin(theta)*Math.cos(phi);
      const y=500*Math.cos(theta);
      const z=500*Math.sin(theta)*Math.sin(phi);
      points.push(new THREE.Vector3(x,y,z));
    }
    sphereGroup.add(createTubeFromPoints(points, lineThickness));
  }

  // ê°€ë¡œì„ 
  for(let j=0;j<=latLines;j++){
    const theta=(j/latLines)*Math.PI;
    const points=[];
    for(let i=0;i<=lonLines;i++){
      const phi=(i/lonLines)*2*Math.PI;
      const x=500*Math.sin(theta)*Math.cos(phi);
      const y=500*Math.cos(theta);
      const z=500*Math.sin(theta)*Math.sin(phi);
      points.push(new THREE.Vector3(x,y,z));
    }
    sphereGroup.add(createTubeFromPoints(points, lineThickness));
  }


  

  // TubeGeometry í•¨ìˆ˜
  function createTubeFromPoints(points, radius = 1, radialSegments = 6) {
    class CustomCurve extends THREE.Curve {
      constructor(points) { super(); this.points = points; }
      getPoint(t) {
        const idx = t*(this.points.length-1);
        const i = Math.floor(idx);
        const frac = idx-i;
        if(i>=this.points.length-1) return this.points[this.points.length-1];
        return new THREE.Vector3().lerpVectors(this.points[i], this.points[i+1], frac);
      }
    }
    const curve = new CustomCurve(points);
    const geometry = new THREE.TubeGeometry(curve, points.length*2, radius, radialSegments, false);
    const material = new THREE.MeshBasicMaterial({ color:0xffffff });
    const mesh = new THREE.Mesh(geometry, material);
    return mesh;
  }


  for(let i=0;i<=lonLines;i++){
    const phi = (i/lonLines)*2*Math.PI;
    const points = [];
    for(let j=0;j<=latLines;j++){
      const theta = (j/latLines)*Math.PI;
      const x = radius*Math.sin(theta)*Math.cos(phi);
      const y = radius*Math.cos(theta);
      const z = radius*Math.sin(theta)*Math.sin(phi);
      points.push(new THREE.Vector3(x,y,z));
    }
    verticalLines.push(points);
    sphereGroup.add(createTubeFromPoints(points,lineThickness));
  }

  for(let j=0;j<=latLines;j++){
    const theta = (j/latLines)*Math.PI;
    const points = [];
    for(let i=0;i<=lonLines;i++){
      const phi = (i/lonLines)*2*Math.PI;
      const x = radius*Math.sin(theta)*Math.cos(phi);
      const y = radius*Math.cos(theta);
      const z = radius*Math.sin(theta)*Math.sin(phi);
      points.push(new THREE.Vector3(x,y,z));
    }
    horizontalLines.push(points);
    sphereGroup.add(createTubeFromPoints(points,lineThickness));
  }

  // ---------------------------
  // ê²©ì ì¤‘ì‹¬ì— WebGL Plane + CSS3DObject ìƒì„±
  const planeWidths = [100, 100, 150, 150, 100, 100];   // ê° ì¸µ(layer)ë³„ ê°€ë¡œ í¬ê¸°
  const planeHeights = [100, 240, 240, 240, 240, 100];   // ê° ì¸µë³„ ì„¸ë¡œ í¬ê¸°
  let inputCount=1, faceCount=1;

  for(let j=0;j<latLines;j++){
    // âœ… ì²« ë²ˆì§¸ ì¸µê³¼ ë§ˆì§€ë§‰ ì¸µì€ plane, text ëª¨ë‘ ìƒëµ
    if (j === 0 || j === latLines - 1) continue;
    const planeWidth = planeWidths[j % planeWidths.length];   // ì¸µ indexì— ë§ê²Œ ë°˜ë³µ ì ìš© ê°€ëŠ¥
    const planeHeight = planeHeights[j % planeHeights.length];

    for(let i=0;i<lonLines;i++){
      // ì‚¬ê°í˜• 4ê°œ ì 
      const p00 = verticalLines[i][j];
      const p01 = verticalLines[i][j+1];
      const p10 = verticalLines[i+1][j];
      const p11 = verticalLines[i+1][j+1];

      // ì¤‘ì‹¬ ê³„ì‚°
      let center;
      if (j === 0) {
        // ì²« ë²ˆì§¸ ì¤„: ë§¨ ì•„ë˜ ì  ê¸°ì¤€
        center = new THREE.Vector3().addVectors(p00,p01).add(p10).add(p11).multiplyScalar(0.5);
      } else if (j === latLines - 1) {
        // ë§ˆì§€ë§‰ ì¤„: ë§¨ ìœ„ ì  ê¸°ì¤€
        center = new THREE.Vector3().addVectors(p01, p11).multiplyScalar(0.5);
      } else {
        // ì¤‘ê°„ ì¤„: ê¸°ì¡´ í‰ê· 
        center = new THREE.Vector3().addVectors(p00,p01).add(p10).add(p11).multiplyScalar(0.25);
      }


      // WebGL Plane
      const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
      const material = new THREE.MeshBasicMaterial({ visible:false });
      const plane = new THREE.Mesh(geometry, material);
      plane.position.copy(center);
      plane.lookAt(0,0,0);
      sphereGroup.add(plane);

      // âœ… ë²ˆí˜¸ í…ìŠ¤íŠ¸ ì¶”ê°€
      if (loadedFont) {
        const textGeo = new TextGeometry(faceCount.toString(), {
          font: loadedFont,
          size: 11,
          // size: 40,
          height: 0.3,
          curveSegments: 4,
          bevelEnabled: false
        });

        // âœ… í…ìŠ¤íŠ¸ ì¤‘ì‹¬ ë³´ì •
        textGeo.computeBoundingBox();
        const bbox = textGeo.boundingBox;
        const textCenter = new THREE.Vector3(
          (bbox.max.x + bbox.min.x) / 2,
          // (bbox.max.y + bbox.min.y) * 4,
          (bbox.max.y + bbox.min.y) * 10,
          (bbox.max.z + bbox.min.z) / 2
        );
        textGeo.translate(-textCenter.x, -textCenter.y, -textCenter.z);

        const textMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const textMesh = new THREE.Mesh(textGeo, textMaterial);

        // âœ… planeì˜ ì¤‘ì‹¬ì— ì •í™•íˆ ë°°ì¹˜
        textMesh.position.copy(center);

        // âœ… í…ìŠ¤íŠ¸ê°€ í•­ìƒ ì¹´ë©”ë¼ë¥¼ í–¥í•˜ê²Œ
        textMesh.lookAt(camera.position);

        sphereGroup.add(textMesh);
      }


      faceCount++;


      // CSS3D Plane
      const div = document.createElement('div');
      div.className='plane-wrapper';
      div.style.width = planeWidth+'px';
      div.style.height = planeHeight+'px';

      const inputsPerPlane = 180;
      for(let k=0;k<inputsPerPlane;k++){
        const input = document.createElement('input');
        input.type='text';
        input.maxLength=1;
        input.className='inputPlane';
        input.id='input'+(inputCount++);
        div.appendChild(input);
        allInputs.push(input);


        // input.addEventListener('input', () => {
        //   const idx = allInputs.indexOf(input);
        //   const planeId = Math.floor(idx / 180);
        //   const inputIndex = idx % 180;
        //   const value = input.value;

        //   console.log({ planeId, inputIndex, value }); // â† ì„œë²„ ì—†ì´ í…ŒìŠ¤íŠ¸ ê°€ëŠ¥

        //   if (value.trim() !== '') {
        //     input.classList.add('input-texted');
        //   } else {
        //     input.classList.remove('input-texted');
        //   }
        // });
      // âœ… ì…ë ¥ ì´ë²¤íŠ¸ ë“±ë¡ (ìƒì„±ê³¼ ë™ì‹œì—)
      input.addEventListener('input', () => {
        const idx = allInputs.indexOf(input);
        const planeId = Math.floor(idx / 180);
        const inputIndex = idx % 180;
        const value = input.value;

        // Socket.io ì„œë²„ë¡œ ì „ì†¡
        socket.emit('inputChange', { planeId, inputIndex, value });

        // ê¸€ì ì²˜ë¦¬ UI
        if (value.trim() !== '') {
          input.classList.add('input-texted');
        } else {
          input.classList.remove('input-texted');
        }
      });

        // ì…ë ¥ ì´ë²¤íŠ¸ (ì‚¬ìš©ìê°€ ê¸€ìë¥¼ ì…ë ¥í•  ë•Œ)\
        // input.addEventListener('input', () => {
        //   // í˜„ì¬ input ì„ íƒ
        //   input.select();

        //   // ê¸€ì ìƒíƒœ ë°˜ì˜
        //   if (input.value.trim() !== '') {
        //     input.classList.add('input-texted');
        //     // ë‹¤ìŒ inputìœ¼ë¡œ ìë™ í¬ì»¤ìŠ¤
        //     const nextInput = document.getElementById('input' + (parseInt(input.id.replace('input','')) + 1));
        //     if (nextInput) nextInput.focus();
        //   } else {
        //     input.classList.remove('input-texted');
        //   }
        // });

let isComposing = false;

input.addEventListener('compositionstart', () => {
  isComposing = true;
});

input.addEventListener('compositionend', () => {
  isComposing = false;

  // ê¸€ì ì™„ë£Œ ì²˜ë¦¬: í˜„ì¬ inputì— ì…ë ¥ í™•ì •
  input.classList.remove('focused');
  input.classList.add('input-texted');

  // ë‹¤ìŒ inputìœ¼ë¡œ í¬ì»¤ìŠ¤ ì´ë™
  const nextIndex = parseInt(input.id.replace('input', '')) + 1;
  const nextInput = document.getElementById('input' + nextIndex);

  if (nextInput) {
    // ë‹¤ìŒ inputì—ì„œ IME ì¡°í•©ì´ ì‹œì‘ë˜ë„ë¡ ì•½ê°„ ë”œë ˆì´
    setTimeout(() => {
      nextInput.focus();
      nextInput.select();
    }, 0);
  }
});

// ì¼ë°˜ input ì´ë²¤íŠ¸ ì²˜ë¦¬ (ì˜ë¬¸ ë“±)
input.addEventListener('input', (e) => {
  if (!isComposing && input.value.trim() !== '') {
    input.classList.remove('focused');
    input.classList.add('input-texted');

    const nextIndex = parseInt(input.id.replace('input', '')) + 1;
    const nextInput = document.getElementById('input' + nextIndex);

    if (nextInput) {
      setTimeout(() => {
        nextInput.focus();
        nextInput.select();
      }, 0);
    }
  } else if (input.value.trim() === '') {
    input.classList.remove('input-texted');
  }
});








        // í¬ì»¤ìŠ¤ ì´ë²¤íŠ¸
        input.addEventListener('focus', () => {
          input.classList.remove('input-texted');
          input.classList.add('focused');
        });

        // ë¸”ëŸ¬ ì´ë²¤íŠ¸ (í¬ì»¤ìŠ¤ í•´ì œ ì‹œ)
        input.addEventListener('blur', () => {
          input.classList.remove('focused');
          if (input.value.trim() !== '') {
            input.classList.add('input-texted');
          }
        });

        // ì…ë ¥ ì´ë²¤íŠ¸ (ì‚¬ìš©ìê°€ ê¸€ìë¥¼ ì…ë ¥í•  ë•Œ)
        input.addEventListener('keydown',(e)=>{
          if(e.key==='Backspace' && input.value===''){
            const prevIndex = allInputs.indexOf(input)-1;
            if(prevIndex>=0){
              const prevInput = allInputs[prevIndex];
              prevInput.focus();
              prevInput.value='';
              e.preventDefault();
            }
          }
        });
        // input.addEventListener('input', () => {
        //   if (input.value.trim() !== '') {
        //     input.classList.remove('focused');
        //     input.classList.add('input-texted');
        //   } else {
        //     input.classList.remove('input-texted');
        //   }
        // });

        div.appendChild(input);
      }


      const object = new CSS3DObject(div);
      object.position.copy(center);
      object.lookAt(0,0,0);
      sphereGroup.add(object);
    }
  }

  // window.addEventListener('keydown', e=>{ if(keys.hasOwnProperty(e.key)) keys[e.key]=true; });
  // window.addEventListener('keyup', e=>{ if(keys.hasOwnProperty(e.key)) keys[e.key]=false; });
    // âœ… ë°©í–¥í‚¤ ì´ë™ ë¡œì§
  window.addEventListener('keydown', (e) => {
    if (keys.hasOwnProperty(e.key)) keys[e.key] = true;

    const currentInput = document.activeElement;
    const currentIndex = allInputs.indexOf(currentInput);

    if (e.key === 'ArrowRight') {
      rotationY += speed; // íšŒì „
      if (currentIndex >= 0 && currentIndex < allInputs.length - 1) {
        e.preventDefault();
        allInputs[currentIndex + 1].focus();
      }
    } else if (e.key === 'ArrowLeft') {
      rotationY -= speed; // íšŒì „
      if (currentIndex > 0) {
        e.preventDefault();
        allInputs[currentIndex - 1].focus();
      }
    }
  });

  window.addEventListener('keyup', (e) => {
    if (keys.hasOwnProperty(e.key)) keys[e.key] = false;
  });


  window.addEventListener('resize', ()=>{
    camera.aspect=window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    webGLRenderer.setSize(window.innerWidth, window.innerHeight);
    cssRenderer.setSize(window.innerWidth, window.innerHeight);
  });
}


// ---------------------------
// ëª¨ë“  plane JSON ë¶ˆëŸ¬ì˜¤ê¸°
function loadAllPlanes(){
  const totalPlanes = Math.ceil(allInputs.length/180);
  for(let planeId=0; planeId<totalPlanes; planeId++){
    fetch(`/plane_${planeId}.json`)
      .then(res=>res.json())
      .then(data=>{
        data.forEach((value,inputIndex)=>{
          const globalIndex = planeId*180 + inputIndex;
          const targetInput = allInputs[globalIndex];
          if(targetInput){
            targetInput.value = value || '';
            if(value && value.trim()!=='') targetInput.classList.add('input-texted');
          }
        });
      }).catch(err=>{
        console.warn(`Plane ${planeId} JSON not found.`);
      });
  }
}

// ---------------------------
// ì„œë²„ì—ì„œ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ ë°›ê¸°
socket.on('updateInput', ({planeId,inputIndex,value})=>{
  const globalIndex = planeId*180 + inputIndex;
  const targetInput = allInputs[globalIndex];
  if(!targetInput) return;
  targetInput.value = value || '';
  if(value && value.trim()!=='') targetInput.classList.add('input-texted');
  else targetInput.classList.remove('input-texted');
});


// ---------------------------
// ì œí•œê°’ ì •ì˜
const minRotationX = -Math.PI / 2; // -90ë„
const maxRotationX = Math.PI / 2;  // +90ë„

function animate(time = 0) {
  requestAnimationFrame(animate);

  // í‚¤ ì…ë ¥ì— ë”°ë¼ íšŒì „
  if (keys.ArrowUp) rotationX -= speed;
  if (keys.ArrowDown) rotationX += speed;
  if (keys.ArrowLeft) rotationY -= speed;
  if (keys.ArrowRight) rotationY += speed;

  // íšŒì „ ì œí•œ ì ìš© (Xì¶•ë§Œ)
  rotationX = Math.max(minRotationX, Math.min(maxRotationX, rotationX));

  // êµ¬ ì „ì²´ íšŒì „
  sphereGroup.rotation.x = rotationX;
  sphereGroup.rotation.y = rotationY;

  // ë¶ê·¹/ë‚¨ê·¹ êµ¬ë¦„ íšŒì „
  if (cloudNorth) cloudNorth.rotation.y += 0.001;  // ì‹œê³„ ë°©í–¥
  if (cloudSouth) cloudSouth.rotation.y -= 0.001;  // ë°˜ì‹œê³„ ë°©í–¥

  // ë°°ê²½ ê·¸ë¼ë””ì–¸íŠ¸ ì—…ë°ì´íŠ¸
  updateGradient(time);

  // ë Œë”ë§
  webGLRenderer.render(scene, camera);
  cssRenderer.render(scene, camera);
}
</script>


</body>
</html>