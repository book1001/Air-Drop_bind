<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>Bind the Air</title>
<!-- <link rel="shortcut icon" href="favicon.png"> -->

<link rel="stylesheet" href="font.css">
<style>
  body {
    margin: 0;
    background: blue;
    /* background-image: url("img/sky_1.jpg"); */
    overflow: hidden;
  }

  canvas {
    position: absolute;
    top: 0;
    left: 0;
    z-index: 0;
    pointer-events: none;
  }

  #cssRenderer {
    position: absolute;
    top: 0;
    left: 0;
    z-index: 2;
  }

  /* --- plane-wrapper --- */
  .plane-wrapper {
    display: grid;
    /* grid-template-columns: repeat(10, 1fr);
    grid-template-rows: repeat(12, 1fr); */
    backface-visibility: hidden;
    transform-style: preserve-3d;
    will-change: transform;
    image-rendering: pixelated;
    -webkit-font-smoothing: none;
    -moz-osx-font-smoothing: grayscale;

    grid-auto-columns: 1fr; 
    grid-auto-rows: 1fr; 
    grid-template-columns: 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr; 
    grid-template-rows: 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr; 
    gap: 0px 0px; 
    grid-template-areas: 
      ". . . . . . . . ."
      ". . . . . . . . ."
      ". . . . . . . . ."
      ". . . . . . . . ."
      ". . . . . . . . ."
      ". . . . . . . . ."
      ". . . . . . . . ."
      ". . . . . . . . ."
      ". . . . . . . . ."
      ". . . . . . . . ."
      ". . . . . . . . ."
      ". . . . . . . . ."
      ". . . . . . . . ."
      ". . . . . . . . ."; 
    /* background: red; */
  }

  /* --- input field --- */
  .inputPlane {
    width: 100%;
    height: 100%;
    /* width: 6px;
    height: 9px; */
    padding: 0;
    margin: 0;
    font-size: 11px;
    line-height: 9px;
    text-align: center;
    font-family: FKGroteskMonoTrial-Regular;
    text-transform: uppercase;
    border: 1px solid white;
    border: none;
    color: gray;
    background: transparent;
    pointer-events: auto;
    outline: none;

    /* ✨ 핵심: 흐림 제거 */
    -webkit-font-smoothing: none !important;
    text-rendering: geometricPrecision;
    filter: none;
    transform: translate3d(0, 0, 0) scale(1.0001);
    backface-visibility: hidden;
  }

  /* 포커스 시에도 blur 안 생김 */
  .inputPlane:focus {
    background: transparent;
    border: none;
    outline: none;
    filter: none;
    transform: translate3d(0, 0, 0) scale(1.0001);
  }

  .input-texted {
    position: relative;
    /* animation: float 3s ease-in-out infinite; */
    /* animation: float-3d 3s infinite ease-in-out alternate; */
  }

  @keyframes float {
      0% {
          transform: translateY(0);
      }

      50% {
          transform: translateY(-20px);
      }

      100% {
          transform: translateY(0);
      }
  }

  @keyframes float-3d {
    from {
      transform: translateZ(0) rotateX(0deg); /* Starting position and rotation */
    }
    to {
      transform: translateZ(20px) rotateX(10deg); /* Floating closer and tilting */
    }
  }


  #bg-video {
    position: fixed;
    top: 0; left: 0;
    width: 100vw;
    height: 100vh;
    object-fit: cover;
    z-index: -1;
  }
</style>


<script src="/socket.io/socket.io.js"></script>
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/"
  }
}
</script>
</head>

<body>
  <div style="position: fixed; top: 10px; left: 15px; width: 35%; z-index: 3;"></div>

  <script type="module">
    import * as THREE from 'three';
    import { CSS3DRenderer, CSS3DObject } from 'three/addons/renderers/CSS3DRenderer.js';
    import { FontLoader } from 'three/addons/loaders/FontLoader.js';
    import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    
    const socket = io();
    const inputsCount = 180;
    let allInputs = [];
    let planeCount = 0; // 실제 plane 수

    let loadedFont=null;
    new FontLoader().load('font/FK Grotesk SemiMono Trial_Regular.json', f => { loadedFont=f; init(); animate(); });

    let scene, camera, webGLRenderer, cssRenderer, sphereGroup, backgroundMesh, texture, ctx, canvas;
    let rotationX=0, rotationY=0;
    const keys={ArrowUp:false, ArrowDown:false, ArrowLeft:false, ArrowRight:false};
    const speed=0.02;

    const gltfLoader=new GLTFLoader();
    let cloudSouth;

    // background gradients (생략 생략 - 동일)
    const gradients = {
      dawn: ['#1a237e','#3949ab','#81d4fa'],
      morning:['#81d4fa','#fff176','#ffb74d'],
      noon:['#81d4fa','#fff176','#ffb74d'],
      evening:['#ff8a65','#f06292','#ba68c8'],
      night:['#00afff','#4ADBFF','#ffffff']
    };
    let currentPalette = gradients[getTimeOfDay()];
    let targetPalette = currentPalette.slice();
    let lastUpdate = 0;

    function getTimeOfDay(){ const hour = new Date().getHours(); if(hour>=4 && hour<8) return 'dawn'; if(hour>=8 && hour<12) return 'morning'; if(hour>=12 && hour<17) return 'noon'; if(hour>=17 && hour<21) return 'evening'; return 'night'; }
    function hexToRgb(hex){ if(hex.startsWith('rgb')){ const [r,g,b]=hex.match(/\d+/g).map(Number); return {r,g,b}; } const bigint=parseInt(hex.replace('#',''),16); return { r:(bigint>>16)&255, g:(bigint>>8)&255, b:bigint&255 }; }
    function blendColors(c1,c2,t){ const a=hexToRgb(c1), b=hexToRgb(c2); const r=Math.round(a.r+(b.r-a.r)*t); const g=Math.round(a.g+(b.g-a.g)*t); const b2=Math.round(a.b+(b.b-a.b)*t); return `rgb(${r},${g},${b2})`; }
    function updateGradient(time){
      const now = getTimeOfDay();
      if(time - lastUpdate > 10000){ targetPalette = gradients[now]; lastUpdate = time; }
      for(let i=0;i<3;i++) currentPalette[i] = blendColors(currentPalette[i], targetPalette[i], 0.02);
      const gradient = ctx.createLinearGradient(0,0,0,window.innerHeight);
      gradient.addColorStop(0, currentPalette[0]);
      gradient.addColorStop(0.5, currentPalette[1]);
      gradient.addColorStop(1, currentPalette[2]);
      ctx.fillStyle = gradient;
      ctx.fillRect(0,0,canvas.width,canvas.height);
      texture.needsUpdate = true;
    }

    // --- Init ---
    function init(){
      scene=new THREE.Scene();
      camera=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,1000);
      camera.position.set(0,0,0);

      webGLRenderer=new THREE.WebGLRenderer({antialias:true,alpha:true});
      webGLRenderer.setSize(window.innerWidth,window.innerHeight);
      document.body.appendChild(webGLRenderer.domElement);

      cssRenderer=new CSS3DRenderer();
      cssRenderer.setSize(window.innerWidth,window.innerHeight);
      cssRenderer.domElement.id="cssRenderer";
      document.body.appendChild(cssRenderer.domElement);

      sphereGroup=new THREE.Group();
      scene.add(sphereGroup);

      // background canvas
      canvas = document.createElement('canvas');
      const dpr = window.devicePixelRatio || 1;
      canvas.width = window.innerWidth * dpr;
      canvas.height = window.innerHeight * dpr;
      ctx = canvas.getContext('2d');
      ctx.scale(dpr, dpr);

      texture = new THREE.CanvasTexture(canvas);
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.generateMipmaps = false;
      texture.needsUpdate = true;
      
      const radius=500;
      const geo=new THREE.SphereGeometry(radius,64,64);
      const mat=new THREE.MeshBasicMaterial({map:texture,side:THREE.BackSide});
      const sphereMesh=new THREE.Mesh(geo,mat);
      sphereGroup.add(sphereMesh);

      // clouds (남극만 예시 - 북극은 주석 처리 가능)
      gltfLoader.load('img/cloud.glb', (gltf) => {
        cloudSouth = gltf.scene;
        cloudSouth.traverse((child)=>{ if(child.isMesh){ child.material = new THREE.MeshBasicMaterial({ map: child.material.map, side: THREE.DoubleSide, transparent: true, opacity: 0.8, depthWrite:false, alphaTest:0.5 }); }});
        cloudSouth.scale.set(50,50,50);
        cloudSouth.position.set(0,-radius,0);
        sphereGroup.add(cloudSouth);
      });

      // --- Grid + Planes ---
      const latLines=6, lonLines=16;
      const lineThickness = 1;
      const verticalLines=[], horizontalLines=[];

      function createTubeFromPoints(points, radius=1, radialSegments=6){
        class CustomCurve extends THREE.Curve { constructor(points){ super(); this.points=points; } getPoint(t){ const idx=t*(this.points.length-1); const i=Math.floor(idx); const frac=idx-i; if(i>=this.points.length-1) return this.points[this.points.length-1]; return new THREE.Vector3().lerpVectors(this.points[i], this.points[i+1], frac); } }
        const curve = new CustomCurve(points);
        const geom = new THREE.TubeGeometry(curve, points.length*2, radius, radialSegments, false);
        const mat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        return new THREE.Mesh(geom, mat);
      }

      
      for(let i=0;i<=lonLines;i++){
        const phi = (i/lonLines)*2*Math.PI;
        const points=[];
        for(let j=0;j<=latLines;j++){
          const theta=(j/latLines)*Math.PI;
          const x=radius*Math.sin(theta)*Math.cos(phi);
          const y=radius*Math.cos(theta);
          const z=radius*Math.sin(theta)*Math.sin(phi);
          points.push(new THREE.Vector3(x,y,z));
        }
        verticalLines.push(points);
        sphereGroup.add(createTubeFromPoints(points,lineThickness));
      }
      for(let j=0;j<=latLines;j++){
        const theta=(j/latLines)*Math.PI;
        const points=[];
        for(let i=0;i<=lonLines;i++){
          const phi=(i/lonLines)*2*Math.PI;
          const x=radius*Math.sin(theta)*Math.cos(phi);
          const y=radius*Math.cos(theta);
          const z=radius*Math.sin(theta)*Math.sin(phi);
          points.push(new THREE.Vector3(x,y,z));
        }
        horizontalLines.push(points);
        sphereGroup.add(createTubeFromPoints(points,lineThickness));
      }

      // planes + CSS3D inputs 생성 (원본 로직 유지)
      const planeWidths=[100,100,150,150,100,100];
      const planeHeights=[100,240,240,240,240,100];
      let inputCount = 1;
      let faceCount = 1;

      for(let j=1;j<latLines-1;j++){
        const planeW=planeWidths[j%planeWidths.length];
        const planeH=planeHeights[j%planeHeights.length];

        for(let i=0;i<lonLines;i++){
          const p00 = verticalLines[i][j];
          const p01 = verticalLines[i][j+1];
          const p10 = verticalLines[i+1][j];
          const p11 = verticalLines[i+1][j+1];

          const center=new THREE.Vector3().addVectors(p00,p01).add(p10).add(p11).multiplyScalar(0.25);

          const div=document.createElement('div');
          div.className='plane-wrapper';
          div.style.width=planeW+'px';
          div.style.height=planeH+'px';

          for(let k=0;k<inputsCount;k++){
            const input=document.createElement('input');
            input.type='text'; input.maxLength=1;
            input.className='inputPlane';
            input.id='input'+(inputCount);
            div.appendChild(input);
            allInputs.push(input);

            const planeId=Math.floor(inputCount/inputsCount);
            const inputIndex=inputCount%inputsCount;
            setupInput(input, planeId, inputIndex);
            inputCount++;
          }

          const object=new CSS3DObject(div);
          object.position.copy(center);
          object.lookAt(0,0,0);
          sphereGroup.add(object);

          if(loadedFont){
            const textGeo=new TextGeometry(faceCount.toString(),{font:loadedFont,size:11,height:0.3,curveSegments:4,bevelEnabled:false});
            textGeo.computeBoundingBox();
            const bbox=textGeo.boundingBox;
            const textCenter = new THREE.Vector3(
              (bbox.max.x + bbox.min.x) / 2,
              // (bbox.max.y + bbox.min.y) * 4,
              (bbox.max.y + bbox.min.y) * 10,
              (bbox.max.z + bbox.min.z) / 2
            );
            textGeo.translate(-textCenter.x,-textCenter.y,-textCenter.z);
            const textMesh=new THREE.Mesh(textGeo,new THREE.MeshBasicMaterial({color:0xffffff}));
            textMesh.position.copy(center);
            textMesh.lookAt(camera.position);
            sphereGroup.add(textMesh);
          }

          faceCount++;
        }
      }

      planeCount = Math.ceil(allInputs.length/inputsCount);
      requestAllPlanes();
      
      // 윈도우 이벤트
      window.addEventListener('keydown', (e) => {
        if(keys.hasOwnProperty(e.key)) keys[e.key] = true;
        const currentInput = document.activeElement;
        const currentIndex = allInputs.indexOf(currentInput);
        if(e.key === 'ArrowRight'){ rotationY += speed; if(currentIndex >= 0 && currentIndex < allInputs.length - 1){ e.preventDefault(); allInputs[currentIndex + 1].focus(); } }
        else if(e.key === 'ArrowLeft'){ rotationY -= speed; if(currentIndex > 0){ e.preventDefault(); allInputs[currentIndex - 1].focus(); } }
      });
      window.addEventListener('keyup', (e)=>{ if(keys.hasOwnProperty(e.key)) keys[e.key] = false; });
      window.addEventListener('resize', ()=>{ camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); webGLRenderer.setSize(window.innerWidth, window.innerHeight); cssRenderer.setSize(window.innerWidth, window.innerHeight); });
    } // init()


    // --- Input Event Setup ---
    function setupInput(input, planeId, inputIndex){
      let isComposing=false;
      input.addEventListener('compositionstart',()=>isComposing=true);
      input.addEventListener('compositionend',()=>isComposing=false);
      input.addEventListener('input',()=>{
        if(isComposing) return;
        socket.emit('inputChange',{planeId,inputIndex,value:input.value});
        input.value.trim()!=='' ? input.classList.add('input-texted') : input.classList.remove('input-texted');
      });
    }

    // --- 요청 ---
    function requestAllPlanes(){
      for(let planeId=0; planeId<planeCount; planeId++){
        socket.emit('requestPlaneData', planeId);
      }
    }

    // --- 서버에서 load ---
    socket.on('loadPlaneData', ({planeId,data})=>{
      for(let i=0;i<inputsCount;i++){
        const globalIndex=planeId*inputsCount+i;
        const input=allInputs[globalIndex];
        if(!input) continue;
        const value=data['input'+i]||'';
        input.value=value;
        value.trim()!=='' ? input.classList.add('input-texted') : input.classList.remove('input-texted');
      }
    });

    // --- 서버에서 실시간 update ---
    socket.on('updateInput', ({planeId,inputIndex,value})=>{
      const globalIndex=planeId*inputsCount+inputIndex;
      const input=allInputs[globalIndex];
      if(!input) return;
      input.value=value||'';
      if(value && value.trim()!=='') input.classList.add('input-texted');
      else input.classList.remove('input-texted');
    });

    // --- Animate ---
    const minRotationX = -Math.PI/2;
    const maxRotationX = Math.PI/2;

    function animate(time = 0){
      requestAnimationFrame(animate);
      if(keys.ArrowUp) rotationX -= speed;
      if(keys.ArrowDown) rotationX += speed;
      if(keys.ArrowLeft) rotationY -= speed;
      if(keys.ArrowRight) rotationY += speed;
      rotationX = Math.max(minRotationX, Math.min(maxRotationX, rotationX));
      sphereGroup.rotation.x = rotationX;
      sphereGroup.rotation.y = rotationY;
      if(cloudSouth) cloudSouth.rotation.y -= 0.001;
      updateGradient(time);
      webGLRenderer.render(scene, camera);
      cssRenderer.render(scene, camera);
    }
    </script>



</body>
</html>
