<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>Bind the Air</title>
<!-- <link rel="shortcut icon" href="favicon.png"> -->

<!-- css -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@670&family=Noto+Sans+SC:wght@600&family=Noto+Sans+TC:wght@638&display=swap" rel="stylesheet">

<link rel="stylesheet" href="font.css">
<link rel="stylesheet" href="index.css">
<link rel="stylesheet" href="index_detail.css">
<link rel="stylesheet" href="index_media.css">


<style>
  body {
    margin: 0;
    background: blue;
    /* background-image: url("img/sky_1.jpg"); */
    overflow: hidden;
    cursor: grab;
  }

  canvas {
    position: absolute;
    top: 0;
    left: 0;
    z-index: 0;
    pointer-events: none;
    background: linear-gradient(0deg,rgba(0, 251, 255, 1) 0%, rgba(255, 255, 255, 1) 9%, rgba(216, 249, 255, 1) 18%, rgba(0, 220, 255, 1) 65%);
  }

  #cssRenderer {
    position: absolute;
    top: 0;
    left: 0;
    z-index: 2;
    background: transparent !important;
  }

  /* --- plane-wrapper --- */
  .plane-wrapper {
    display: grid;
    /* grid-template-columns: repeat(10, 1fr);
    grid-template-rows: repeat(12, 1fr); */
    backface-visibility: hidden;
    transform-style: preserve-3d;
    will-change: transform;
    image-rendering: pixelated;
    -webkit-font-smoothing: none;
    -moz-osx-font-smoothing: grayscale;

    grid-auto-columns: 1fr; 
    grid-auto-rows: 1fr; 
    grid-template-columns: 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr; 
    grid-template-rows: 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr; 
    gap: 0px 0px; 
    grid-template-areas: 
      ". . . . . . . . ."
      ". . . . . . . . ."
      ". . . . . . . . ."
      ". . . . . . . . ."
      ". . . . . . . . ."
      ". . . . . . . . ."
      ". . . . . . . . ."
      ". . . . . . . . ."
      ". . . . . . . . ."
      ". . . . . . . . ."
      ". . . . . . . . ."
      ". . . . . . . . ."
      ". . . . . . . . ."
      ". . . . . . . . ."; 
    /* background: red; */
  }

  /* --- input field --- */
  .inputPlane {
    width: 100%;
    height: 100%;
    /* width: 6px;
    height: 9px; */
    padding: 0;
    margin: 0;
    font-size: 11px;
    line-height: 9px;
    text-align: center;
    font-family: FKGroteskMonoTrial-Regular;
    text-transform: uppercase;
    border: 1px solid white;
    border: none;
    color: white;
    font-family: 'FKGroteskMonoTrial-Regular', 'Noto Sans KR', 'Noto Sans SC', sans-serif;
    text-shadow: 0 0 1px #ffffff;
    background: transparent;
    pointer-events: auto;
    outline: none;

    /* ✨ 핵심: 흐림 제거 */
    -webkit-font-smoothing: none !important;
    text-rendering: geometricPrecision;
    filter: none;
    transform: translate3d(0, 0, 0) scale(1.0001);
    backface-visibility: hidden;
  }

  /* 포커스 시에도 blur 안 생김 */
  .inputPlane:focus {
    background: transparent;
    border: none;
    outline: none;
    filter: none;
    transform: translate3d(0, 0, 0) scale(1.0001);
  }

  .input-texted {
    position: relative;
    /* animation: float 3s ease-in-out infinite; */
    /* animation: float-3d 3s infinite ease-in-out alternate; */
  }


  .float1 {
    animation: float 3s ease-in-out infinite;
    animation-delay: 0s;
  }

  .float2 {
    animation: float 3s ease-in-out infinite;
    animation-delay: 0.5s;
  }

  .float3 {
    animation: float 3s ease-in-out infinite;
    animation-delay: 1s;
  }

  @keyframes float {
      0% {
          transform: translateY(0);
      }

      50% {
          transform: translateY(-20px);
      }

      100% {
          transform: translateY(0);
      }
  }

  @keyframes float-3d {
    from {
      transform: translateZ(0) rotateX(0deg); /* Starting position and rotation */
    }
    to {
      transform: translateZ(20px) rotateX(10deg); /* Floating closer and tilting */
    }
  }





  #bg-video {
    position: fixed;
    top: 0; left: 0;
    width: 100vw;
    height: 100vh;
    object-fit: cover;
    z-index: -1;
  }

  .info {
    position: fixed; 
    top: 3px;
    left: 9px;
    width: 100%;
    z-index: 3; 
    /* font-family: 'FKGroteskNeueTrial-Bold'; */
    /* font-family: 'AppleChancery';
    color: red;
    font-size: 36px; */
    /* text-shadow: 0 0 1px #ffffff;
    letter-spacing: 0.027em;
    text-transform: uppercase;
    text-align: justify; */

    /* color: #ff6ff7; */

    /* font-family: Menlo-Regular;
    font-size: 24px;
    background: black;
    text-transform: uppercase; */
    font-family: 'FKGroteskNeueTrial-Bold';
    font-size: 19px;
    color: black;
    text-shadow: 0 0 6px #ffffff;
  }
</style>

<!-- script: socket -->
<script src="/socket.io/socket.io.js"></script>
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/"
  }
}
</script>
</head>

<body>
  <!-- <div class="info">
     command + > Move Right<br>
     command + < Move Left<br>
  </div> -->
  <div class="info">
    By scanning the QR code on the wall, the sky’s scattered pages come together on their mobile devices.
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { CSS3DRenderer, CSS3DObject } from 'three/addons/renderers/CSS3DRenderer.js';
    import { FontLoader } from 'three/addons/loaders/FontLoader.js';
    import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    
    const socket = io();
    const inputsCount = 180;
    let allInputs = [];
    let planeCount = 0; // 실제 plane 수

    let loadedFont=null;
    // new FontLoader().load('font/FK Grotesk SemiMono Trial_Regular.json', f => { loadedFont=f; init(); animate(); });

    let font1 = null;
    let font2 = null;

    new FontLoader().load('font/FKGroteskSemiMonoTrial_Regular.json', f => {
        font1 = f;
        checkAllFontsLoaded();
    });

    new FontLoader().load('font/ReadyActiveTest-Light5.json', f => {
        font2 = f;
        checkAllFontsLoaded();
    });

    function checkAllFontsLoaded() {
        if(font1 && font2) {
            init();
            animate();
        }
    }



    let scene, camera, webGLRenderer, cssRenderer, sphereGroup, backgroundMesh, texture, ctx, canvas;
    let rotationX=0, rotationY=0;
    const keys={ArrowUp:false, ArrowDown:false, ArrowLeft:false, ArrowRight:false};
    const speed=0.02;

    const gltfLoader=new GLTFLoader();
    const textMeshes = [];  // animate에서 회전시키기 위해 저장
    let cloudSouth;

    // background gradients (생략 생략 - 동일)
    const gradients = {
      dawn: ['#1a237e','#3949ab','#81d4fa'],
      morning:['#81d4fa','#fff176','#ffb74d'],
      noon:['#00afff','#4ADBFF','#ffffff'],
      evening:['#00afff','#4ADBFF','#ffffff'],
      night:['#00afff','#4ADBFF','#ffffff']
    };
    // const gradients = {
    //   dawn: ['#1a237e','#3949ab','#81d4fa'],
    //   morning:['#81d4fa','#fff176','#ffb74d'],
    //   noon:['#81d4fa','#fff176','#ffb74d'],
    //   evening:['#ff8a65','#f06292','#ba68c8'],
    //   night:['#00afff','#4ADBFF','#ffffff']
    // };
    let currentPalette = gradients[getTimeOfDay()];
    let targetPalette = currentPalette.slice();
    let lastUpdate = 0;

    function getTimeOfDay(){ const hour = new Date().getHours(); if(hour>=4 && hour<8) return 'dawn'; if(hour>=8 && hour<12) return 'morning'; if(hour>=12 && hour<17) return 'noon'; if(hour>=17 && hour<21) return 'evening'; return 'night'; }
    function hexToRgb(hex){ if(hex.startsWith('rgb')){ const [r,g,b]=hex.match(/\d+/g).map(Number); return {r,g,b}; } const bigint=parseInt(hex.replace('#',''),16); return { r:(bigint>>16)&255, g:(bigint>>8)&255, b:bigint&255 }; }
    function blendColors(c1,c2,t){ const a=hexToRgb(c1), b=hexToRgb(c2); const r=Math.round(a.r+(b.r-a.r)*t); const g=Math.round(a.g+(b.g-a.g)*t); const b2=Math.round(a.b+(b.b-a.b)*t); return `rgb(${r},${g},${b2})`; }
    function updateGradient(time){
      // const now = getTimeOfDay();
      // if(time - lastUpdate > 10000){ targetPalette = gradients[now]; lastUpdate = time; }
      // for(let i=0;i<3;i++) currentPalette[i] = blendColors(currentPalette[i], targetPalette[i], 0.02);
      // const gradient = ctx.createLinearGradient(0,0,0,window.innerHeight);
      // gradient.addColorStop(0, currentPalette[0]);
      // gradient.addColorStop(0.5, currentPalette[1]);
      // gradient.addColorStop(1, currentPalette[2]);
      // ctx.fillStyle = gradient;
      // ctx.fillRect(0,0,canvas.width,canvas.height);
      // texture.needsUpdate = true;
    }
    // function updateGradient(time) {
    //   const now = getTimeOfDay();
    //   if (time - lastUpdate > 10000) {
    //     targetPalette = gradients[now];
    //     lastUpdate = time;
    //   }

    //   for (let i = 0; i < 3; i++)
    //     currentPalette[i] = blendColors(currentPalette[i], targetPalette[i], 0.02);

    //   const gradient = ctx.createLinearGradient(0, 0, 0, window.innerHeight);
    //   gradient.addColorStop(0, currentPalette[0]);
    //   gradient.addColorStop(0.5, currentPalette[1]);
    //   gradient.addColorStop(1, currentPalette[2]);
    //   ctx.fillStyle = gradient;
    //   ctx.fillRect(0, 0, canvas.width, canvas.height);

    //   // --- 감마 보정 (어둡게) ---
    //   const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    //   const data = imageData.data;
    //   for (let i = 0; i < data.length; i += 4) {
    //     const gamma = 2.4; // 1.8~2.4 사이에서 미세 조정 가능
    //     data[i] = Math.pow(data[i] / 255, gamma) * 255;    // R
    //     data[i + 1] = Math.pow(data[i + 1] / 255, 2.2) * 255; // G
    //     data[i + 2] = Math.pow(data[i + 2] / 255, 2.2) * 255; // B
    //   }
    //   ctx.putImageData(imageData, 0, 0);
    //   // -----------------

    //   texture.needsUpdate = true;
    // }


    
    // --- Init ---
    function init(){
      scene=new THREE.Scene();
      // camera=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,1000);
      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000); // 1000 → 2000

      camera.position.set(0,0,0);

      webGLRenderer=new THREE.WebGLRenderer({antialias:true,alpha:true});
      webGLRenderer.setClearColor(0x000000, 0);
      webGLRenderer.setSize(window.innerWidth,window.innerHeight);
      document.body.appendChild(webGLRenderer.domElement);

      cssRenderer=new CSS3DRenderer();
      cssRenderer.setSize(window.innerWidth,window.innerHeight);
      cssRenderer.domElement.id="cssRenderer";
      document.body.appendChild(cssRenderer.domElement);

      sphereGroup=new THREE.Group();
      scene.add(sphereGroup);
      scene.background = null;

      // background canvas
      canvas = document.createElement('canvas');
      const dpr = window.devicePixelRatio || 1;
      canvas.width = window.innerWidth * dpr;
      canvas.height = window.innerHeight * dpr;
      ctx = canvas.getContext('2d');
      ctx.scale(dpr, dpr);

      texture = new THREE.CanvasTexture(canvas);
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.generateMipmaps = false;
      texture.encoding = THREE.sRGBEncoding;
      texture.needsUpdate = true;
      
      const radius=500;
      const geo=new THREE.SphereGeometry(radius,64,64);
      // const mat=new THREE.MeshBasicMaterial({map:texture,side:THREE.BackSide});
      // 완전 투명한 배경만 남기려면:
      const mat = new THREE.MeshBasicMaterial({
        transparent: true,
        opacity: 0,
        side: THREE.BackSide
      });

      const sphereMesh=new THREE.Mesh(geo,mat);
      sphereGroup.add(sphereMesh);

       // --- 3D Text letters on sphere ---
      const letters = ['B','I','N','D','T','H','E','A','I','R'];
      const baseOffset = 50; // 기본 구 내부 거리

      if (font2) {
        letters.forEach(letter => {
          const textGeo = new TextGeometry(letter, {
            font: font2,
            size: 150,
            height: 2,
            curveSegments: 4,
            bevelEnabled: false
          });
          textGeo.computeBoundingBox();
          const bbox = textGeo.boundingBox;
          const textCenter = new THREE.Vector3(
            (bbox.max.x + bbox.min.x)/2,
            (bbox.max.y + bbox.min.y)/2,
            (bbox.max.z + bbox.min.z)/2
          );
          textGeo.translate(-textCenter.x, -textCenter.y, -textCenter.z);

          const material = new THREE.MeshBasicMaterial({ 
            color: 0xffffff,
            transparent: true,
            opacity: 0 // 처음에는 안보이도록
          });
          const textMesh = new THREE.Mesh(textGeo, material);

          // 랜덤 회전 속도
          const speed = (Math.random() * 0.015) + 0.005;
          textMesh.userData.rotationSpeed = Math.random() < 0.5 ? speed : -speed;

          // fade 효과와 위치 이동을 위한 유저 데이터
          textMesh.userData.fadeSpeed = 0.005 + Math.random() * 0.01; // 0.005~0.015
          textMesh.userData.fadeDirection = 1; // 1: 나타남, -1: 사라짐
          textMesh.userData.startDelay = Math.random() * 2000; // 시작 시간 랜덤 (ms)
          textMesh.userData.lastChangeTime = performance.now();

          // 랜덤 위치 설정 함수 → mesh를 인자로 받음
          textMesh.userData.setRandomPosition = function(mesh) {
            const offset = baseOffset + Math.random() / 20;
            const phi = Math.random() * Math.PI;
            const theta = Math.random() * 2 * Math.PI;
            mesh.position.set(
              (radius - offset) * Math.sin(phi) * Math.cos(theta),
              (radius - offset) * Math.cos(phi),
              (radius - offset) * Math.sin(phi) * Math.sin(theta)
            );
            mesh.lookAt(new THREE.Vector3(0,0,0));
          };

          // 초기 위치 → textMesh를 전달
          textMesh.userData.setRandomPosition(textMesh);

          sphereGroup.add(textMesh);
          textMeshes.push(textMesh);
        });
      }





      // clouds (남극만 예시 - 북극은 주석 처리 가능)
      gltfLoader.load('model/cloud.glb', (gltf) => {
        cloudSouth = gltf.scene;
        cloudSouth.traverse((child)=>{ if(child.isMesh){ child.material = new THREE.MeshBasicMaterial({ map: child.material.map, side: THREE.DoubleSide, transparent: true, opacity: 0.8, depthWrite:false, alphaTest:0.5 }); }});
        cloudSouth.scale.set(50,50,50);
        cloudSouth.position.set(0,-radius,0);
        sphereGroup.add(cloudSouth);
      });




      // --- Grid + Planes ---
      const latLines=6, lonLines=16;
      const lineThickness = 1;
      const verticalLines=[], horizontalLines=[];

      function createTubeFromPoints(points, radius=1, radialSegments=6){
        class CustomCurve extends THREE.Curve { constructor(points){ super(); this.points=points; } getPoint(t){ const idx=t*(this.points.length-1); const i=Math.floor(idx); const frac=idx-i; if(i>=this.points.length-1) return this.points[this.points.length-1]; return new THREE.Vector3().lerpVectors(this.points[i], this.points[i+1], frac); } }
        const curve = new CustomCurve(points);
        const geom = new THREE.TubeGeometry(curve, points.length*2, radius, radialSegments, false);
        const mat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        return new THREE.Mesh(geom, mat);
      }

      
      for(let i=0;i<=lonLines;i++){
        const phi = (i/lonLines)*2*Math.PI;
        const points=[];
        for(let j=0;j<=latLines;j++){
          const theta=(j/latLines)*Math.PI;
          const x=radius*Math.sin(theta)*Math.cos(phi);
          const y=radius*Math.cos(theta);
          const z=radius*Math.sin(theta)*Math.sin(phi);
          points.push(new THREE.Vector3(x,y,z));
        }
        verticalLines.push(points);
        sphereGroup.add(createTubeFromPoints(points,lineThickness));
      }
      for(let j=0;j<=latLines;j++){
        const theta=(j/latLines)*Math.PI;
        const points=[];
        for(let i=0;i<=lonLines;i++){
          const phi=(i/lonLines)*2*Math.PI;
          const x=radius*Math.sin(theta)*Math.cos(phi);
          const y=radius*Math.cos(theta);
          const z=radius*Math.sin(theta)*Math.sin(phi);
          points.push(new THREE.Vector3(x,y,z));
        }
        horizontalLines.push(points);
        sphereGroup.add(createTubeFromPoints(points,lineThickness));
      }

      // planes + CSS3D inputs 생성 (원본 로직 유지)
      const planeWidths=[100,100,150,150,100,100];
      const planeHeights=[100,240,240,240,240,100];
      let inputCount = 1;
      let faceCount = 1;

      for(let j=1;j<latLines-1;j++){
        const planeW=planeWidths[j%planeWidths.length];
        const planeH=planeHeights[j%planeHeights.length];

        for(let i=0;i<lonLines;i++){
          const p00 = verticalLines[i][j];
          const p01 = verticalLines[i][j+1];
          const p10 = verticalLines[i+1][j];
          const p11 = verticalLines[i+1][j+1];

          const center=new THREE.Vector3().addVectors(p00,p01).add(p10).add(p11).multiplyScalar(0.25);

          const div=document.createElement('div');
          div.className='plane-wrapper';
          div.style.width=planeW+'px';
          div.style.height=planeH+'px';

          for(let k=0;k<inputsCount;k++){
            const input=document.createElement('input');
            input.type='text'; 
            input.className='inputPlane';
            input.id='input'+(inputCount);
            div.appendChild(input);
            allInputs.push(input);

            const pageId = Math.floor((inputCount-1)/inputsCount) + 1; // 1부터 시작
            const inputIndex = (inputCount-1) % inputsCount;
            setupInput(input, pageId, inputIndex);
            inputCount++;
          }

          const object=new CSS3DObject(div);
          object.position.copy(center);
          object.lookAt(0,0,0);
          sphereGroup.add(object);

          if(font1){
            const textGeo = new TextGeometry(faceCount.toString(), {
              font: font1,
              size: 11,
              height: 0.3,
              curveSegments: 4,
              bevelEnabled: false
            });
            textGeo.computeBoundingBox();
            const bbox=textGeo.boundingBox;
            const textCenter = new THREE.Vector3(
              (bbox.max.x + bbox.min.x) / 2,
              // (bbox.max.y + bbox.min.y) * 4,
              (bbox.max.y + bbox.min.y) * 10,
              (bbox.max.z + bbox.min.z) / 2
            );
            textGeo.translate(-textCenter.x,-textCenter.y,-textCenter.z);
            const textMesh=new THREE.Mesh(textGeo,new THREE.MeshBasicMaterial({color:0xffffff}));
            textMesh.position.copy(center);
            textMesh.lookAt(camera.position);
            sphereGroup.add(textMesh);
          }

          faceCount++;
        }
      }

      planeCount = Math.ceil(allInputs.length/inputsCount);
      requestAllPages();
      
      // 윈도우 이벤트
      window.addEventListener('keydown', (e) => {
        if(keys.hasOwnProperty(e.key)) keys[e.key] = true;
        const currentInput = document.activeElement;
        const currentIndex = allInputs.indexOf(currentInput);
        if(e.key === 'ArrowRight'){ rotationY += speed; if(currentIndex >= 0 && currentIndex < allInputs.length - 1){ e.preventDefault(); allInputs[currentIndex + 1].focus(); } }
        else if(e.key === 'ArrowLeft'){ rotationY -= speed; if(currentIndex > 0){ e.preventDefault(); allInputs[currentIndex - 1].focus(); } }
      });
      window.addEventListener('keyup', (e)=>{ if(keys.hasOwnProperty(e.key)) keys[e.key] = false; });
      window.addEventListener('resize', ()=>{ camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); webGLRenderer.setSize(window.innerWidth, window.innerHeight); cssRenderer.setSize(window.innerWidth, window.innerHeight); });
    } // init()


    // --- Input Event Setup ---

    function setupInput(input, pageId, inputIndex) {
      let isComposing = false;
      let composedText = "";

      // 입력 옵션
      input.inputMode = 'text';
      input.autocapitalize = 'off';
      input.autocorrect = 'off';
      input.spellcheck = false;
      input.style.imeMode = 'active'; // IME 사용 가능

      input.addEventListener("compositionstart", () => {
        isComposing = true;
        composedText = "";
        input.value = ""; // 조합 시작 시 입력 숨김
      });

      input.addEventListener("compositionupdate", (e) => {
        isComposing = true;
        composedText = e.data; // 현재 조합 중인 문자열 저장
        input.value = ""; // 영어/한자 조합 문자 표시 금지
      });

      input.addEventListener("compositionend", (e) => {
        isComposing = false;
        composedText = e.data || composedText;
        // input.value = ""; // 화면에 표시하지 않음

        if (composedText.length > 0) {
          distributeCharacters(composedText);
          composedText = "";
        }
      });

      input.addEventListener("input", () => {
        if (isComposing) return; // 조합 중이면 무시

        const val = input.value;
        if (val.trim() === "") return;

        distributeCharacters(val);
      });

      input.addEventListener("keydown", (e) => {
        const currentIndex = allInputs.indexOf(input);

        // 백스페이스 처리 (keyCode 8)
        if (e.keyCode === 8 && input.value === "") {
          e.preventDefault();
          if (currentIndex > 0) {
            const prevInput = allInputs[currentIndex - 1];
            prevInput.value = ""; // 이전 input 삭제
            prevInput.classList.remove("input-texted");

            socket.emit("inputChange", {
              pageId,
              inputIndex: currentIndex - 1,
              value: ""
            });

            prevInput.focus();
          }
        }

        // 스페이스 처리 → 다음 input으로 이동 (keyCode 32)
        if (e.keyCode === 32) {
          e.preventDefault();
          if (currentIndex < allInputs.length - 1) {
            allInputs[currentIndex + 1].focus();
          }
        }
      });

      function distributeCharacters(text) {
        const chars = [...text]; // 한자, 한글, 이모지 모두 처리
        let currentIndex = allInputs.indexOf(input);

        chars.forEach((ch) => {
          if (currentIndex >= allInputs.length) return;

          const target = allInputs[currentIndex];
          target.value = ch;
          target.classList.add("input-texted");

          socket.emit("inputChange", {
            pageId,
            inputIndex: currentIndex,
            value: ch
          });

          currentIndex++;
        });

        // 마지막 입력 후 포커스 이동
        if (currentIndex < allInputs.length) {
          allInputs[currentIndex].focus();
        } else {
          allInputs[allInputs.length - 1].focus();
        }
      }
    }



    // function setupInput(input, pageId, inputIndex) {
    //   let isComposing = false;
    //   let composedText = "";

    //   // 입력 옵션
    //   input.inputMode = 'text';
    //   input.autocapitalize = 'off';
    //   input.autocorrect = 'off';
    //   input.spellcheck = false;
    //   input.style.imeMode = 'active'; // IME 사용 가능

    //   input.addEventListener("compositionstart", () => {
    //     isComposing = true;
    //     composedText = "";
    //     input.value = ""; // 조합 시작 시 입력 숨김
    //   });

    //   input.addEventListener("compositionupdate", (e) => {
    //     isComposing = true;
    //     composedText = e.data; // 현재 조합 중인 문자열 저장
    //     input.value = ""; // 영어/한자 조합 문자 표시 금지
    //   });

    //   input.addEventListener("compositionend", (e) => {
    //     isComposing = false;
    //     composedText = e.data || composedText;
    //     // input.value = ""; // 화면에 표시하지 않음

    //     if (composedText.length > 0) {
    //       distributeCharacters(composedText);
    //       composedText = "";
    //     }
    //   });

    //   input.addEventListener("input", () => {
    //     if (isComposing) return; // 조합 중이면 무시

    //     const val = input.value;
    //     if (val.trim() === "") return;

    //     distributeCharacters(val);
    //   });

    //   input.addEventListener("keydown", (e) => {
    //     const currentIndex = allInputs.indexOf(input);

    //     // 백스페이스 처리 (keyCode 8)
    //     if (e.keyCode === 8 && input.value === "") {
    //       e.preventDefault();
    //       if (currentIndex > 0) {
    //         const prevInput = allInputs[currentIndex - 1];
    //         prevInput.value = ""; // 이전 input 삭제
    //         prevInput.classList.remove("input-texted");

    //         socket.emit("inputChange", {
    //           pageId,
    //           inputIndex: currentIndex - 1,
    //           value: ""
    //         });

    //         prevInput.focus();
    //       }
    //     }

    //     // 스페이스 처리 → 다음 input으로 이동 (keyCode 32)
    //     if (e.keyCode === 32) {
    //       e.preventDefault();
    //       if (currentIndex < allInputs.length - 1) {
    //         allInputs[currentIndex + 1].focus();
    //       }
    //     }
    //   });


    //   function distributeCharacters(text) {
    //     const chars = [...text]; // 한자, 한글, 이모지 모두 처리
    //     let currentIndex = allInputs.indexOf(input);

    //     chars.forEach((ch) => {
    //       if (currentIndex >= allInputs.length) return;

    //       const target = allInputs[currentIndex];
    //       target.value = ch;
    //       target.classList.add("input-texted");

    //       socket.emit("inputChange", {
    //         pageId,
    //         inputIndex: currentIndex,
    //         value: ch
    //       });

    //       currentIndex++;
    //     });

    //     // 마지막 입력 후 포커스 이동
    //     if (currentIndex < allInputs.length) {
    //       allInputs[currentIndex].focus();
    //     } else {
    //       allInputs[allInputs.length - 1].focus();
    //     }
    //   }
    // }


    // function setupInput(input, pageId, inputIndex) {
    //   let isComposing = false;
    //   let composedText = "";

    //   // 입력 옵션
    //   input.inputMode = 'text';
    //   input.autocapitalize = 'off';
    //   input.autocorrect = 'off';
    //   input.spellcheck = false;
    //   input.style.imeMode = 'active'; // IME 사용 가능

    //   input.addEventListener("compositionstart", () => {
    //     isComposing = true;
    //     composedText = "";
    //     input.value = ""; // 조합 시작 시 입력 숨김
    //   });

    //   input.addEventListener("compositionupdate", (e) => {
    //     isComposing = true;
    //     composedText = e.data; // 현재 조합 중인 문자열 저장
    //     input.value = ""; // 영어/한자 조합 문자 표시 금지
    //   });

    //   input.addEventListener("compositionend", (e) => {
    //     isComposing = false;
    //     composedText = e.data || composedText;
    //     input.value = ""; // 화면에 표시하지 않음

    //     if (composedText.length > 0) {
    //       distributeCharacters(composedText);
    //       composedText = "";
    //     }
    //   });

    //   input.addEventListener("input", () => {
    //     if (isComposing) return; // 조합 중이면 무시

    //     const val = input.value;
    //     if (val.trim() === "") return;

    //     distributeCharacters(val);
    //   });

    //   input.addEventListener("keydown", (e) => {
    //     const currentIndex = allInputs.indexOf(input);

    //     // 백스페이스 처리 (keyCode 8)
    //     if (e.keyCode === 8 && input.value === "") {
    //       e.preventDefault();
    //       if (currentIndex > 0) {
    //         const prevInput = allInputs[currentIndex - 1];
    //         prevInput.value = ""; // 이전 input 삭제
    //         prevInput.classList.remove("input-texted");

    //         socket.emit("inputChange", {
    //           pageId,
    //           inputIndex: currentIndex - 1,
    //           value: ""
    //         });

    //         prevInput.focus();
    //       }
    //     }

    //     // 스페이스 처리 → 다음 input으로 이동 (keyCode 32)
    //     if (e.keyCode === 32) {
    //       e.preventDefault();
    //       if (currentIndex < allInputs.length - 1) {
    //         allInputs[currentIndex + 1].focus();
    //       }
    //     }
    //   });


    //   function distributeCharacters(text) {
    //     const chars = [...text]; // 한자, 한글, 이모지 모두 처리
    //     let currentIndex = allInputs.indexOf(input);

    //     chars.forEach((ch) => {
    //       if (currentIndex >= allInputs.length) return;

    //       const target = allInputs[currentIndex];
    //       target.value = ch;
    //       target.classList.add("input-texted");

    //       socket.emit("inputChange", {
    //         pageId,
    //         inputIndex: currentIndex,
    //         value: ch
    //       });

    //       currentIndex++;
    //     });

    //     // 마지막 입력 후 포커스 이동
    //     if (currentIndex < allInputs.length) {
    //       allInputs[currentIndex].focus();
    //     } else {
    //       allInputs[allInputs.length - 1].focus();
    //     }
    //   }
    // }




    // function setupInput(input, pageId, inputIndex){
    //   let isComposing = false;

    //   input.addEventListener('compositionstart', () => isComposing = true);
    //   input.addEventListener('compositionend', () => isComposing = false);

    //   input.addEventListener('input', (e) => {
    //     if(isComposing) return;

    //     // ✅ 현재 상태 업데이트 서버로 전송
    //     socket.emit('inputChange', { pageId, inputIndex, value: input.value });

    //     // ✅ 스타일 토글
    //     input.value.trim() !== '' 
    //       ? input.classList.add('input-texted')
    //       : input.classList.remove('input-texted');

    //     const currentIndex = allInputs.indexOf(input);

    //     // ✅ 한 글자 입력 후 자동 이동
    //     if(input.value.length === 1 && currentIndex < allInputs.length - 1){
    //       allInputs[currentIndex + 1].focus();
    //     }
    //   });

    //   input.addEventListener('keydown', (e) => {
    //     const currentIndex = allInputs.indexOf(input);

    //     // ✅ 백스페이스 시 이전 input으로 이동
    //     if(e.key === 'Backspace' && input.value === '' && currentIndex > 0){
    //       e.preventDefault();
    //       const prev = allInputs[currentIndex - 1];
    //       prev.focus();
    //       prev.value = ''; // 원하면 삭제 유지
    //       socket.emit('inputChange', { pageId, inputIndex: currentIndex - 1, value: '' });
    //     }

    //     // ✅ 좌우 화살표 이동 지원 (기존 적용 유지)
    //     if(e.key === 'ArrowLeft' && currentIndex > 0){
    //       e.preventDefault();
    //       allInputs[currentIndex - 1].focus();
    //     }
    //     if(e.key === 'ArrowRight' && currentIndex < allInputs.length - 1){
    //       e.preventDefault();
    //       allInputs[currentIndex + 1].focus();
    //     }
    //   });
    // }

    // function setupInput(input, pageId, inputIndex){
    //   let isComposing=false;
    //   input.addEventListener('compositionstart',()=>isComposing=true);
    //   input.addEventListener('compositionend',()=>isComposing=false);
    //   input.addEventListener('input',()=>{
    //     if(isComposing) return;
    //     socket.emit('inputChange',{pageId,inputIndex,value:input.value});
    //     input.value.trim()!=='' ? input.classList.add('input-texted') : input.classList.remove('input-texted');
    //   });
    // }

    // --- 요청 ---
    function requestAllPages(){
      for(let pageId=1; pageId<=planeCount; pageId++){
        socket.emit('requestPlaneData', pageId);
      }
    }

    // --- 서버에서 load ---
    socket.on('loadPlaneData', ({pageId,data})=>{
      for(let i=0;i<inputsCount;i++){
        const globalIndex=(pageId-1)*inputsCount + i;
        const input=allInputs[globalIndex];
        if(!input) continue;
        const value=data['input'+i]||'';
        input.value=value;
        value.trim()!=='' ? input.classList.add('input-texted') : input.classList.remove('input-texted');
      }
    });
    
    // --- 서버에서 실시간 update ---
    socket.on('updateInput', ({pageId,inputIndex,value})=>{
      const globalIndex=(pageId-1)*inputsCount + inputIndex;
      const input=allInputs[globalIndex];
      if(!input) return;
      input.value=value||'';
      if(value && value.trim()!=='') input.classList.add('input-texted');
      else input.classList.remove('input-texted');
    });


    // --- Animate ---
    const minRotationX = -Math.PI/2;
    const maxRotationX = Math.PI/2;

    function animate(time = 0){
      requestAnimationFrame(animate);
      if(keys.ArrowUp) rotationX -= speed;
      if(keys.ArrowDown) rotationX += speed;
      if(keys.ArrowLeft) rotationY -= speed;
      if(keys.ArrowRight) rotationY += speed;
      rotationX = Math.max(minRotationX, Math.min(maxRotationX, rotationX));
      sphereGroup.rotation.x = rotationX;
      sphereGroup.rotation.y = rotationY;
      if(cloudSouth) cloudSouth.rotation.y -= 0.001;

      // 글자별 y축 회전
      const now = performance.now();
      textMeshes.forEach(mesh => {
        // y축 회전
        mesh.rotation.y += mesh.userData.rotationSpeed;

        const fullRotation = 2 * Math.PI;
        let normalizedRotation = Math.abs(mesh.rotation.y % fullRotation);

        // 회전 시작 → 빠른 fade in
        if (normalizedRotation < 0.2) {
          mesh.userData.fadeDirection = 1;   // 나타남
          mesh.userData.fadeSpeed = 0.08;    // 빠른 fade in
        }

        // 회전 끝 → 빠른 fade out
        if (normalizedRotation > fullRotation - 0.2) {
          mesh.userData.fadeDirection = -1;  // 사라짐
          mesh.userData.fadeSpeed = 0.08;    // 빠른 fade out
        }

        // fade in/out 적용
        if (mesh.userData.fadeDirection === 1) {
          mesh.material.opacity += mesh.userData.fadeSpeed;
          if (mesh.material.opacity > 1) mesh.material.opacity = 1;
        } else if (mesh.userData.fadeDirection === -1) {
          mesh.material.opacity -= mesh.userData.fadeSpeed;
          if (mesh.material.opacity <= 0) {
            mesh.material.opacity = 0;

            // 🔁 완전히 사라졌을 때: 새로운 위치에서 다시 나타나도록 설정
            mesh.userData.setRandomPosition(mesh);
            mesh.rotation.y = 0; // 회전 초기화
            mesh.userData.fadeDirection = 1; // 다시 fade in 시작
          }
        }
      });




      updateGradient(time);
      webGLRenderer.render(scene, camera);
      cssRenderer.render(scene, camera);
    }
    </script>



</body>
</html>
