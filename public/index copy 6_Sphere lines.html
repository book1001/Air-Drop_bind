<!-- <!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Crisp Inputs in CSS3DRenderer</title>
<style>
  body {
    margin: 0;
    background: #111;
    overflow: hidden;
  }

  canvas {
    position: absolute;
    top: 0;
    left: 0;
    z-index: 0;
    pointer-events: none;
  }

  #cssRenderer {
    position: absolute;
    top: 0;
    left: 0;
    z-index: 2;
  }

  /* --- plane-wrapper --- */
  .plane-wrapper {
    display: grid;
    grid-template-columns: repeat(10, 1fr);
    grid-template-rows: repeat(12, 1fr);
    backface-visibility: hidden;
    transform-style: preserve-3d;
    will-change: transform;
    image-rendering: pixelated;
    -webkit-font-smoothing: none;
    -moz-osx-font-smoothing: grayscale;
  }

  /* --- input field --- */
  .inputPlane {
    width: 6px;
    height: 9px;
    padding: 0;
    margin: 0;
    font-size: 6px;
    line-height: 9px;
    text-align: center;
    font-family: monospace;
    border: none;
    color: #fff;
    background: transparent;
    pointer-events: auto;
    outline: none;

    /* ‚ú® ÌïµÏã¨: ÌùêÎ¶º Ï†úÍ±∞ */
    -webkit-font-smoothing: none !important;
    text-rendering: geometricPrecision;
    filter: none;
    transform: translate3d(0, 0, 0) scale(1.0001);
    backface-visibility: hidden;
  }

  /* Ìè¨Ïª§Ïä§ ÏãúÏóêÎèÑ blur Ïïà ÏÉùÍπÄ */
  .inputPlane:focus {
    background: transparent;
    border: none;
    outline: none;
    filter: none;
    transform: translate3d(0, 0, 0) scale(1.0001);
  }
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/"
  }
}
</script>
</head>

<body>
<script type="module">
import * as THREE from 'three';
import { CSS3DRenderer, CSS3DObject } from 'three/addons/renderers/CSS3DRenderer.js';

let scene, camera, webGLRenderer, cssRenderer, sphereGroup;
let rotationX = 0, rotationY = 0;
const speed = 0.02;
const keys = { ArrowUp:false, ArrowDown:false, ArrowLeft:false, ArrowRight:false };

init();
animate();

function init() {
  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 0, 0);

  webGLRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  webGLRenderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(webGLRenderer.domElement);

  cssRenderer = new CSS3DRenderer();
  cssRenderer.setSize(window.innerWidth, window.innerHeight);
  cssRenderer.domElement.id = "cssRenderer";
  document.body.appendChild(cssRenderer.domElement);

  sphereGroup = new THREE.Group();
  scene.add(sphereGroup);

  const radius = 150;
  const minPlaneSize = 80;
  const latitudes = Math.ceil(Math.PI * radius / minPlaneSize);
  const planeSize = Math.PI * radius / latitudes;

  let inputCount = 1;

  for (let i = 0; i <= latitudes; i++) {
    const theta = i * Math.PI / latitudes;
    const y = radius * Math.cos(theta);
    const r = radius * Math.sin(theta);
    const longitudes = r === 0 ? 1 : Math.ceil(2 * Math.PI * r / planeSize);

    for (let j = 0; j < longitudes; j++) {
      const phi = j * 2 * Math.PI / longitudes;
      const x = r * Math.cos(phi);
      const z = r * Math.sin(phi);

      // WebGL ÌèâÎ©¥
      const geometry = new THREE.PlaneGeometry(planeSize, planeSize);
      const material = new THREE.MeshBasicMaterial({ color: 0xff00ff, side: THREE.DoubleSide});
      // const material = new THREE.MeshBasicMaterial({ visible: false });
      const plane = new THREE.Mesh(geometry, material);
      plane.position.set(x, y, z);
      plane.lookAt(0, 0, 0);
      sphereGroup.add(plane);

      const div = document.createElement('div');
      div.className = 'plane-wrapper';
      div.style.width = planeSize + 'px';
      div.style.height = planeSize + 'px';

      const inputsPerPlane = 120;
      for (let k = 0; k < inputsPerPlane; k++) {
        const input = document.createElement('input');
        input.type = 'text';
        input.maxLength = 1;
        input.className = 'inputPlane';
        input.id = 'input' + (inputCount++);
        div.appendChild(input);
        if (input.id === 'input1') setTimeout(() => input.focus(), 300);
      }

      const object = new CSS3DObject(div);
      object.position.set(x, y, z);
      object.lookAt(0, 0, 0);
      sphereGroup.add(object);
    }
  }

  window.addEventListener('keydown', e => { if (keys.hasOwnProperty(e.key)) keys[e.key] = true; });
  window.addEventListener('keyup', e => { if (keys.hasOwnProperty(e.key)) keys[e.key] = false; });

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    webGLRenderer.setSize(window.innerWidth, window.innerHeight);
    cssRenderer.setSize(window.innerWidth, window.innerHeight);
  });
}

function animate() {
  requestAnimationFrame(animate);

  if (keys.ArrowUp) rotationX -= speed;
  if (keys.ArrowDown) rotationX += speed;
  if (keys.ArrowLeft) rotationY -= speed;
  if (keys.ArrowRight) rotationY += speed;

  sphereGroup.rotation.x = rotationX;
  sphereGroup.rotation.y = rotationY;

  webGLRenderer.render(scene, camera);
  cssRenderer.render(scene, camera);
}
</script>
</body>
</html> -->

<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Crisp Inputs in CSS3DRenderer</title>
<style>
  body {
    margin: 0;
    background: blue;
    /* background-image: url("img/sky_1.jpg"); */
    overflow: hidden;
  }

  canvas {
    position: absolute;
    top: 0;
    left: 0;
    z-index: 0;
    pointer-events: none;
  }

  #cssRenderer {
    position: absolute;
    top: 0;
    left: 0;
    z-index: 2;
  }

  /* --- plane-wrapper --- */
  .plane-wrapper {
    display: grid;
    grid-template-columns: repeat(10, 1fr);
    grid-template-rows: repeat(12, 1fr);
    backface-visibility: hidden;
    transform-style: preserve-3d;
    will-change: transform;
    image-rendering: pixelated;
    -webkit-font-smoothing: none;
    -moz-osx-font-smoothing: grayscale;
    /* border: 1px solid white; */
  }

  /* --- input field --- */
  .inputPlane {
    width: 6px;
    height: 9px;
    padding: 0;
    margin: 0;
    font-size: 6px;
    line-height: 9px;
    text-align: center;
    font-family: monospace;
    text-transform: uppercase;
    border: 1px solid white;
    border: none;
    color: blue;
    background: transparent;
    pointer-events: auto;
    outline: none;

    /* ‚ú® ÌïµÏã¨: ÌùêÎ¶º Ï†úÍ±∞ */
    -webkit-font-smoothing: none !important;
    text-rendering: geometricPrecision;
    filter: none;
    transform: translate3d(0, 0, 0) scale(1.0001);
    backface-visibility: hidden;
  }

  /* Ìè¨Ïª§Ïä§ ÏãúÏóêÎèÑ blur Ïïà ÏÉùÍπÄ */
  .inputPlane:focus {
    background: transparent;
    border: none;
    outline: none;
    filter: none;
    transform: translate3d(0, 0, 0) scale(1.0001);
  }

  .input-texted {
    position: relative;
    /* animation: float 3s ease-in-out infinite; */
    animation: float-3d 3s infinite ease-in-out alternate;
  }

  @keyframes float {
      0% {
          transform: translateY(0);
      }

      50% {
          transform: translateY(-20px);
      }

      100% {
          transform: translateY(0);
      }
  }

  @keyframes float-3d {
    from {
      transform: translateZ(0) rotateX(0deg); /* Starting position and rotation */
    }
    to {
      transform: translateZ(20px) rotateX(10deg); /* Floating closer and tilting */
    }
  }
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/"
  }
}
</script>
</head>

<body>
  <div style="position: fixed; top: 10px; left: 15px; z-index: 3;">
    The internet is the air that grounds us. This shared, vast universe allows us to join, engage, and connect with each other. Here, in Air‚ÄìDrop, you are invited to leave a message or drawing as a gift for an unknown recipient. What you drop will drift through this space, float in the air, and eventually land in someone‚Äôs hands. Let your heart travel around the world! Though we never cross paths, we feel each other through your drops, breathing in the same air.
  </div>

<script type="module">
import * as THREE from 'three';
import { CSS3DRenderer, CSS3DObject } from 'three/addons/renderers/CSS3DRenderer.js';
import { VertexNormalsHelper } from 'three/addons/helpers/VertexNormalsHelper.js'; // sphere Î≤ïÏÑ†


let scene, camera, webGLRenderer, cssRenderer, sphereGroup, backgroundMesh, texture, ctx, canvas;
let rotationX = 0, rotationY = 0;
const speed = 0.02;
const keys = { ArrowUp:false, ArrowDown:false, ArrowLeft:false, ArrowRight:false };

// üåû ÏãúÍ∞ÑÎåÄÎ≥Ñ Í∑∏ÎùºÎîîÏñ∏Ìä∏ ÌåîÎ†àÌä∏
const gradients = {
  dawn:   ['#1a237e', '#3949ab', '#81d4fa'], // ÏÉàÎ≤Ω
  morning:['#81d4fa', '#fff176', '#ffb74d'], // ÏïÑÏπ®
  noon:   ['#64b5f6', '#4dd0e1', '#81c784'], // Ï†êÏã¨
  evening:['#ff8a65', '#f06292', '#ba68c8'], // Ï†ÄÎÖÅ
  night:  ['#00afff', '#4ADBFF', '#ffffff']  // Î∞§
  // night:  ['#0d47a1', '#1a237e', '#000022']  // Î∞§
};

// üïí Ï†ÑÏó≠ Î≥ÄÏàòÎäî Î∞òÎìúÏãú updateGradientÎ≥¥Îã§ Î®ºÏ†Ä ÏÑ†Ïñ∏
let currentPalette = gradients[getTimeOfDay()];
let targetPalette = currentPalette.slice(); // Î≥µÏÇ¨
let lastUpdate = 0;


init();
animate();

// ‚è∞ ÌòÑÏû¨ ÏãúÍ∞ÑÎåÄÏóê ÎßûÎäî Í∑∏ÎùºÎîîÏñ∏Ìä∏ ÏÑ†ÌÉù
function getTimeOfDay() {
  const hour = new Date().getHours();
  if (hour >= 4 && hour < 8)   return 'dawn';     // 4~7Ïãú: ÏÉàÎ≤Ω
  if (hour >= 8 && hour < 12)  return 'morning';  // 8~11Ïãú: ÏïÑÏπ®
  if (hour >= 12 && hour < 17) return 'noon';     // 12~16Ïãú: Ï†êÏã¨
  if (hour >= 17 && hour < 21) return 'evening';  // 17~20Ïãú: Ï†ÄÎÖÅ
  return 'night';                                 // 21~3Ïãú: Î∞§
}

function hexToRgb(hex) {
  if (hex.startsWith('rgb')) {
    // Ïù¥ÎØ∏ rgb Î¨∏ÏûêÏó¥Ïùº Í≤ΩÏö∞ Í∑∏ÎåÄÎ°ú ÌååÏã±
    const [r, g, b] = hex.match(/\d+/g).map(Number);
    return { r, g, b };
  }

  // hex ‚Üí rgb Î≥ÄÌôò
  const bigint = parseInt(hex.replace('#',''), 16);
  return {
    r: (bigint >> 16) & 255,
    g: (bigint >> 8) & 255,
    b: bigint & 255
  };
}

function blendColors(c1, c2, t) {
  const a = hexToRgb(c1);
  const b = hexToRgb(c2);

  const r = Math.round(a.r + (b.r - a.r) * t);
  const g = Math.round(a.g + (b.g - a.g) * t);
  const b2 = Math.round(a.b + (b.b - a.b) * t);

  return `rgb(${r},${g},${b2})`;
}

// üé® Î∞∞Í≤Ω Í∑∏ÎùºÎîîÏñ∏Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏
function updateGradient(time) {
  const now = getTimeOfDay();

  // 10Ï¥àÎßàÎã§ ÏãúÍ∞ÑÎåÄ Ï≤¥ÌÅ¨
  if (time - lastUpdate > 10000) {
    const newPalette = gradients[now];
    if (newPalette !== targetPalette) {
      targetPalette = newPalette;
    }
    lastUpdate = time;
  }

  // ÏÉâÏÉÅ Î≥¥Í∞Ñ (hex ‚Üí rgb ‚Üí Î≥¥Í∞Ñ ÌõÑ rgb)
  for (let i = 0; i < 3; i++) {
    currentPalette[i] = blendColors(currentPalette[i], targetPalette[i], 0.02);
  }

  const gradient = ctx.createLinearGradient(0, 0, 0, window.innerHeight);
  gradient.addColorStop(0, currentPalette[0]);
  gradient.addColorStop(0.5, currentPalette[1]);
  gradient.addColorStop(1, currentPalette[2]);

  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  texture.needsUpdate = true;
}



function init() {
  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 0, 0);

  webGLRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  webGLRenderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(webGLRenderer.domElement);

  cssRenderer = new CSS3DRenderer();
  cssRenderer.setSize(window.innerWidth, window.innerHeight);
  cssRenderer.domElement.id = "cssRenderer";
  document.body.appendChild(cssRenderer.domElement);

  sphereGroup = new THREE.Group();
  scene.add(sphereGroup);

  // üåÑ Î∞∞Í≤ΩÏö© Canvas
  canvas = document.createElement('canvas');
  const dpr = window.devicePixelRatio || 1;
  canvas.width = window.innerWidth * dpr;
  canvas.height = window.innerHeight * dpr;
  ctx = canvas.getContext('2d');

  // Ï∫îÎ≤ÑÏä§ Ï†ÑÏ≤¥ Ïä§ÏºÄÏùº Î≥¥Ï†ï (Í≥†Ìï¥ÏÉÅÎèÑÏóêÏÑúÎèÑ Íπ®ÎÅóÌïòÍ≤å)
  ctx.scale(dpr, dpr);

  texture = new THREE.CanvasTexture(canvas);
  texture.minFilter = THREE.LinearFilter;  // ÌîΩÏÖÄÌôî Î∞©ÏßÄ
  texture.magFilter = THREE.LinearFilter;  // ÌîΩÏÖÄÌôî Î∞©ÏßÄ
  texture.generateMipmaps = false;         // mipmap ÎπÑÌôúÏÑ±Ìôî (Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏ Ïãú ÌïÑÏàò)
  texture.needsUpdate = true;

  // üåå Î∞∞Í≤Ω Íµ¨ ÏÉùÏÑ±
  const geometry = new THREE.SphereGeometry(500, 64, 64);
  const material = new THREE.MeshBasicMaterial({
    map: texture,
    side: THREE.BackSide
  });
  backgroundMesh = new THREE.Mesh(geometry, material);
  sphereGroup.add(backgroundMesh);

 // ----------------------------
  // üåà TubeGeometry Í∏∞Î∞ò Í≤©Ïûê Î≤ïÏÑ† (ÎåÄÍ∞ÅÏÑ† ÏóÜÏùå)
  const latLines = 6;  // ÏÑ∏Î°úÏÑ† Í∞ØÏàò Ï°∞Ï†à
  const lonLines = 16;  // Í∞ÄÎ°úÏÑ† Í∞ØÏàò Ï°∞Ï†à (ÏÑ∏Î°úÏÑ†-1)
  const gridColor = 0xffffff;
  const lineThickness = 1; // ÏõêÌïòÎäî ÎëêÍªò

  // Tube ÏÉùÏÑ±Ïö© Ìï®Ïàò
  function createTubeFromPoints(points, radius = 1, radialSegments = 6) {
    class CustomCurve extends THREE.Curve {
      constructor(points) {
        super();
        this.points = points;
      }
      getPoint(t) {
        const idx = t * (this.points.length - 1);
        const i = Math.floor(idx);
        const frac = idx - i;
        if (i >= this.points.length - 1) return this.points[this.points.length - 1];
        return new THREE.Vector3().lerpVectors(this.points[i], this.points[i + 1], frac);
      }
    }

    const curve = new CustomCurve(points);
    const geometry = new THREE.TubeGeometry(curve, points.length * 2, radius, radialSegments, false);
    const material = new THREE.MeshBasicMaterial({ color: gridColor });
    const mesh = new THREE.Mesh(geometry, material);
    return mesh;
  }

  // ÏÑ∏Î°úÏÑ†
  for (let i = 0; i <= lonLines; i++) {
    const phi = (i / lonLines) * 2 * Math.PI;
    const points = [];
    for (let j = 0; j <= latLines; j++) {
      const theta = (j / latLines) * Math.PI;
      const x = 500 * Math.sin(theta) * Math.cos(phi);
      const y = 500 * Math.cos(theta);
      const z = 500 * Math.sin(theta) * Math.sin(phi);
      points.push(new THREE.Vector3(x, y, z));
    }
    const tube = createTubeFromPoints(points, lineThickness);
    sphereGroup.add(tube);
  }

  // Í∞ÄÎ°úÏÑ†
  for (let j = 0; j <= latLines; j++) {
    const theta = (j / latLines) * Math.PI;
    const points = [];
    for (let i = 0; i <= lonLines; i++) {
      const phi = (i / lonLines) * 2 * Math.PI;
      const x = 500 * Math.sin(theta) * Math.cos(phi);
      const y = 500 * Math.cos(theta);
      const z = 500 * Math.sin(theta) * Math.sin(phi);
      points.push(new THREE.Vector3(x, y, z));
    }
    const tube = createTubeFromPoints(points, lineThickness);
    sphereGroup.add(tube);
  }


  
  const radius = 150;
  const minPlaneSize = 80;
  const latitudes = Math.ceil(Math.PI * radius / minPlaneSize);
  const planeSize = Math.PI * radius / latitudes;

  let inputCount = 1;

  for (let i = 0; i <= latitudes; i++) {
    const theta = i * Math.PI / latitudes;
    const y = radius * Math.cos(theta);
    const r = radius * Math.sin(theta);
    const longitudes = r === 0 ? 1 : Math.ceil(2 * Math.PI * r / planeSize);

    for (let j = 0; j < longitudes; j++) {
      const phi = j * 2 * Math.PI / longitudes;
      const x = r * Math.cos(phi);
      const z = r * Math.sin(phi);

      // WebGL ÌèâÎ©¥
      const geometry = new THREE.PlaneGeometry(planeSize, planeSize);
      // const material = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide});
      const material = new THREE.MeshBasicMaterial({ visible: false });
      const plane = new THREE.Mesh(geometry, material);
      plane.position.set(x, y, z);
      plane.lookAt(0, 0, 0);
      sphereGroup.add(plane);

      const div = document.createElement('div');
      div.className = 'plane-wrapper';
      div.style.width = planeSize + 'px';
      div.style.height = planeSize + 'px';

      const inputsPerPlane = 120;
      for (let k = 0; k < inputsPerPlane; k++) {
        const input = document.createElement('input');
        input.type = 'text';
        input.maxLength = 1;
        input.className = 'inputPlane';
        input.id = 'input' + (inputCount++);

        // ÏûÖÎ†• Ïù¥Î≤§Ìä∏ (ÏÇ¨Ïö©ÏûêÍ∞Ä Í∏ÄÏûêÎ•º ÏûÖÎ†•Ìï† Îïå)\
        // input.addEventListener('input', () => {
        //   // ÌòÑÏû¨ input ÏÑ†ÌÉù
        //   input.select();

        //   // Í∏ÄÏûê ÏÉÅÌÉú Î∞òÏòÅ
        //   if (input.value.trim() !== '') {
        //     input.classList.add('input-texted');
        //     // Îã§Ïùå inputÏúºÎ°ú ÏûêÎèô Ìè¨Ïª§Ïä§
        //     const nextInput = document.getElementById('input' + (parseInt(input.id.replace('input','')) + 1));
        //     if (nextInput) nextInput.focus();
        //   } else {
        //     input.classList.remove('input-texted');
        //   }
        // });

let isComposing = false;

input.addEventListener('compositionstart', () => {
  isComposing = true;
});

input.addEventListener('compositionend', () => {
  isComposing = false;

  // Í∏ÄÏûê ÏôÑÎ£å Ï≤òÎ¶¨: ÌòÑÏû¨ inputÏóê ÏûÖÎ†• ÌôïÏ†ï
  input.classList.remove('focused');
  input.classList.add('input-texted');

  // Îã§Ïùå inputÏúºÎ°ú Ìè¨Ïª§Ïä§ Ïù¥Îèô
  const nextIndex = parseInt(input.id.replace('input', '')) + 1;
  const nextInput = document.getElementById('input' + nextIndex);

  if (nextInput) {
    // Îã§Ïùå inputÏóêÏÑú IME Ï°∞Ìï©Ïù¥ ÏãúÏûëÎêòÎèÑÎ°ù ÏïΩÍ∞Ñ ÎîúÎ†àÏù¥
    setTimeout(() => {
      nextInput.focus();
      nextInput.select();
    }, 0);
  }
});

// ÏùºÎ∞ò input Ïù¥Î≤§Ìä∏ Ï≤òÎ¶¨ (ÏòÅÎ¨∏ Îì±)
input.addEventListener('input', (e) => {
  if (!isComposing && input.value.trim() !== '') {
    input.classList.remove('focused');
    input.classList.add('input-texted');

    const nextIndex = parseInt(input.id.replace('input', '')) + 1;
    const nextInput = document.getElementById('input' + nextIndex);

    if (nextInput) {
      setTimeout(() => {
        nextInput.focus();
        nextInput.select();
      }, 0);
    }
  } else if (input.value.trim() === '') {
    input.classList.remove('input-texted');
  }
});








        // Ìè¨Ïª§Ïä§ Ïù¥Î≤§Ìä∏
        input.addEventListener('focus', () => {
          input.classList.remove('input-texted');
          input.classList.add('focused');
        });

        // Î∏îÎü¨ Ïù¥Î≤§Ìä∏ (Ìè¨Ïª§Ïä§ Ìï¥Ï†ú Ïãú)
        input.addEventListener('blur', () => {
          input.classList.remove('focused');
          if (input.value.trim() !== '') {
            input.classList.add('input-texted');
          }
        });

        // ÏûÖÎ†• Ïù¥Î≤§Ìä∏ (ÏÇ¨Ïö©ÏûêÍ∞Ä Í∏ÄÏûêÎ•º ÏûÖÎ†•Ìï† Îïå)
        input.addEventListener('input', () => {
          if (input.value.trim() !== '') {
            input.classList.remove('focused');
            input.classList.add('input-texted');
          } else {
            input.classList.remove('input-texted');
          }
        });

        div.appendChild(input);
      }


      const object = new CSS3DObject(div);
      object.position.set(x, y, z);
      object.lookAt(0, 0, 0);
      sphereGroup.add(object);
    }
  }

  window.addEventListener('keydown', e => { if (keys.hasOwnProperty(e.key)) keys[e.key] = true; });
  window.addEventListener('keyup', e => { if (keys.hasOwnProperty(e.key)) keys[e.key] = false; });

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    webGLRenderer.setSize(window.innerWidth, window.innerHeight);
    cssRenderer.setSize(window.innerWidth, window.innerHeight);
  });
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  webGLRenderer.setSize(window.innerWidth, window.innerHeight);
  cssRenderer.setSize(window.innerWidth, window.innerHeight);
}

function animate(time = 0) {
  requestAnimationFrame(animate);

  if (keys.ArrowUp) rotationX -= speed;
  if (keys.ArrowDown) rotationX += speed;
  if (keys.ArrowLeft) rotationY -= speed;
  if (keys.ArrowRight) rotationY += speed;

  sphereGroup.rotation.x = rotationX;
  sphereGroup.rotation.y = rotationY;

  updateGradient(time);

  webGLRenderer.render(scene, camera);
  cssRenderer.render(scene, camera);
}
</script>
</body>
</html>