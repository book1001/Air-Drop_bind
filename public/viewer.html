<!-- <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Plane Viewer</title>
  <style>
    body {
      font-family: sans-serif;
      background: #111;
      color: #eee;
      text-align: center;
      padding: 20px;
    }
    #content {
      margin: 30px auto;
      padding: 20px;
      max-width: 800px;
      border: 1px solid #444;
      border-radius: 8px;
      background: #222;
      min-height: 300px;
      white-space: pre-wrap;
      text-align: left;
    }
    button {
      padding: 10px 20px;
      font-size: 18px;
      margin: 10px;
      cursor: pointer;
      background: #444;
      color: #fff;
      border: none;
      border-radius: 6px;
    }
    button:hover {
      background: #666;
    }
    .disabled {
      opacity: 0.3;
      pointer-events: none;
    }
  </style>
</head>
<body>

  <h1 id="title">Plane Viewer</h1>

  <div id="content">Loading...</div>

  <div>
    <button id="prevBtn">Previous</button>
    <button id="nextBtn">Next</button>
  </div>

  <script>
    const MAX_PLANES = 64;
    let currentPlaneId = 0;

    const titleEl = document.getElementById("title");
    const contentEl = document.getElementById("content");
    const prevBtn = document.getElementById("prevBtn");
    const nextBtn = document.getElementById("nextBtn");

    function updateButtons() {
      prevBtn.classList.toggle("disabled", currentPlaneId === 0);
      nextBtn.classList.toggle("disabled", currentPlaneId === MAX_PLANES - 1);
    }

async function loadPlane(planeId) {
  const fileUrl = `/plane_${planeId}.json`; // ✅ 수정됨

  try {
    const res = await fetch(fileUrl);
    if (!res.ok) throw new Error("File not found");

    const data = await res.json();

    titleEl.textContent = `Plane ${planeId}`;

    if (Array.isArray(data) && data.length > 0) {
      contentEl.textContent = data.join("\n");
    } else {
      contentEl.textContent = "(No data yet)";
    }

  } catch (error) {
    titleEl.textContent = `Plane ${planeId}`;
    contentEl.textContent = "(No data yet)";
  }

  updateButtons();
}


    prevBtn.addEventListener("click", () => {
      if (currentPlaneId > 0) {
        currentPlaneId--;
        loadPlane(currentPlaneId);
      }
    });

    nextBtn.addEventListener("click", () => {
      if (currentPlaneId < MAX_PLANES - 1) {
        currentPlaneId++;
        loadPlane(currentPlaneId);
      }
    });

    // 처음 시작
    loadPlane(currentPlaneId);
  </script>
</body>
</html> -->

<!-- ========================================================== -->
<!-- <!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Plane Viewer</title>
<script src="/socket.io/socket.io.js"></script>
<style>
  body { font-family: sans-serif; padding: 20px; }
  #inputs { display: grid; grid-template-columns: repeat(10, 1fr); gap: 5px; margin-bottom: 20px; }
  input { padding: 5px; width: 100%; box-sizing: border-box; }
  button { padding: 10px 20px; margin-right: 10px; }
  #pageIndicator { font-weight: bold; }
</style>
</head>
<body>

<h1>Plane Viewer</h1>
<div id="inputs"></div>

<div>
  <button id="prevBtn">Prev</button>
  <button id="nextBtn">Next</button>
  <span id="pageIndicator">Page 1 / 64</span>
</div>

<script>
const socket = io();

const totalPlanes = 64;
const inputsCount = 180;
let currentPlane = 0;

const inputsContainer = document.getElementById("inputs");
const pageIndicator = document.getElementById("pageIndicator");
const prevBtn = document.getElementById("prevBtn");
const nextBtn = document.getElementById("nextBtn");

// input 생성
const inputElements = [];
for (let i = 0; i < inputsCount; i++) {
  const input = document.createElement("input");
  input.type = "text";
  input.placeholder = `Input ${i+1}`;
  input.dataset.index = i;
  inputsContainer.appendChild(input);
  inputElements.push(input);

  // 실시간 읽기/쓰기
  input.addEventListener("input", (e) => {
    const index = parseInt(e.target.dataset.index);
    const value = e.target.value;

    // 서버에 변경 전송
    socket.emit("inputChange", {
      planeId: currentPlane,
      inputIndex: index,
      value
    });
  });
}

// 페이지 로드
function loadPlane(planeId) {
  currentPlane = planeId;
  pageIndicator.textContent = `Page ${currentPlane + 1} / ${totalPlanes}`;
  socket.emit("requestPlaneData", currentPlane);
}

// 서버에서 데이터 수신 (페이지 로딩)
socket.on("loadPlaneData", ({ planeId, data }) => {
  if (planeId !== currentPlane) return;
  for (let i = 0; i < inputsCount; i++) {
    inputElements[i].value = data[`input${i}`] || '';
  }
});

// 다른 브라우저에서 데이터 변경 시 실시간 반영
socket.on("updateInput", ({ planeId, inputIndex, value }) => {
  if (planeId === currentPlane) {
    const idx = parseInt(inputIndex);
    const input = inputElements[idx];
    if(input) input.value = value || '';
  }
});

// Prev/Next 버튼
prevBtn.addEventListener("click", () => {
  if (currentPlane > 0) loadPlane(currentPlane - 1);
});
nextBtn.addEventListener("click", () => {
  if (currentPlane < totalPlanes - 1) loadPlane(currentPlane + 1);
});

// 초기 페이지
loadPlane(0);

</script>
</body>
</html> -->
<!-- ========================================================== -->


<!-- <!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>Bind the Air</title>

<script src="/socket.io/socket.io.js"></script>
<style>
  body { font-family: sans-serif; padding: 20px; background: #ccfbff; }
  #book {
    position: relative;
    width: 500px;
    height: 800px;
    perspective: 2000px;
    margin: 0 auto 20px;
    touch-action: pan-y;
  }
  .page {
    position: absolute;
    width: 100%;
    height: 100%;
    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    transform-style: preserve-3d;
    transform-origin: left;
    display: grid;
    grid-template-columns: repeat(10, 1fr);
    gap: 5px;
    padding: 20px;
    box-sizing: border-box;
    /* border-left: 1px solid #ccc;
    border-right: 1px solid #ccc;
    border-radius: 2px; */
    border: 4px solid white;
    overflow: hidden;
  }
  input { 
    padding: 0;
    margin: 0;
    width: 100%; 
    box-sizing: border-box;
    color: gray;
    background: transparent;
    border: none;
    outline: none;
  }
  button { padding: 10px 20px; margin-right: 10px; }
  #pageIndicator { 
    position: absolute;
    bottom: 10px;
    left: 50%;
    font-weight: bold; 
    display: inline-block;
    margin-left: 20px; 
    color: white;
  }
</style>
</head>
<body>

<div id="book">
  <div class="page" id="currentPage"></div>
  <div class="page" id="nextPage"></div>
  <span id="pageIndicator">Page 1 / 64</span>
</div>

<div style="display:flex; align-items:center; justify-content:center; margin-bottom:20px;">
  <button id="prevBtn">Prev</button>
  <input type="range" id="pageSlider" value="0" style="flex:1;">
  <button id="nextBtn">Next</button>
</div>

<script>
const socket = io();

const totalPlanes = 64;
const inputsCount = 180;
let currentPlane = 0;

const currentPage = document.getElementById("currentPage");
const nextPage = document.getElementById("nextPage");
const pageIndicator = document.getElementById("pageIndicator");
const prevBtn = document.getElementById("prevBtn");
const nextBtn = document.getElementById("nextBtn");
const book = document.getElementById("book");

let isAnimating = false;

// input 요소 생성
const createInputs = (container) => {
  container.innerHTML = '';
  const inputs = [];
  for(let i=0; i<inputsCount; i++){
    const input = document.createElement('input');
    input.type = 'text'; input.maxLength=1;
    // input.placeholder = `Input ${i+1}`;
    input.dataset.index = i;
    container.appendChild(input);
    inputs.push(input);

    input.addEventListener("input", (e)=>{
      const index = parseInt(e.target.dataset.index);
      const value = e.target.value;
      socket.emit("inputChange", { planeId: currentPlane, inputIndex: index, value });
    });
  }
  return inputs;
}

let currentInputs = createInputs(currentPage);
let nextInputs = createInputs(nextPage);

// 페이지 로드
function loadPlane(planeId) {
  if(planeId < 0 || planeId >= totalPlanes || isAnimating) return;
  currentPlane = planeId;
  pageIndicator.textContent = `Page ${currentPlane + 1} / ${totalPlanes}`;
  socket.emit("requestPlaneData", planeId);
}

// 서버 데이터 수신
socket.on("loadPlaneData", ({ planeId, data }) => {
  if(planeId !== currentPlane) return;
  for(let i=0;i<inputsCount;i++){
    currentInputs[i].value = data[`input${i}`] || '';
  }
});

// 실시간 동기화
socket.on("updateInput", ({ planeId, inputIndex, value }) => {
  if(planeId === currentPlane){
    currentInputs[inputIndex].value = value || '';
  }
});

// Prev/Next 버튼
prevBtn.addEventListener("click", ()=> startFlip("prev"));
nextBtn.addEventListener("click", ()=> startFlip("next"));

const pageSlider = document.getElementById("pageSlider");

// 슬라이더 드래그 중 페이지 전환 비율 계산
let sliderDragging = false;
let sliderTargetPlane = currentPlane;

pageSlider.addEventListener("mousedown", () => { sliderDragging = true; });
pageSlider.addEventListener("mouseup", () => { sliderDragging = false; flipToPage(sliderTargetPlane); });
pageSlider.addEventListener("touchstart", () => { sliderDragging = true; });
pageSlider.addEventListener("touchend", () => { sliderDragging = false; flipToPage(sliderTargetPlane); });

pageSlider.addEventListener("input", (e) => {
  sliderTargetPlane = parseInt(e.target.value);
  // 실시간 페이지 번호 업데이트
  pageIndicator.textContent = `Page ${sliderTargetPlane + 1} / ${totalPlanes}`;

  if(sliderTargetPlane === currentPlane || isAnimating) return;

  // 회전 비율 계산
  const direction = sliderTargetPlane > currentPlane ? "next" : "prev";
  const percent = Math.abs(sliderTargetPlane - currentPlane);

  nextPage.style.transition = "none";
  nextPage.style.transformOrigin = direction==="next" ? "left" : "right";
  nextPage.style.transform = direction==="next" 
    ? `rotateY(${-180 * Math.min(percent,1)}deg)` 
    : `rotateY(${180 * Math.min(percent,1)}deg)`;
});

// 페이지 넘기기 (슬라이더 끝까지 드래그 시)
function flipToPage(targetPlane){
  if(isAnimating) return;
  if(targetPlane < 0 || targetPlane >= totalPlanes) return;

  isAnimating = true;
  const direction = targetPlane > currentPlane ? "next" : "prev";

  nextPage.style.transition = "transform 0.6s cubic-bezier(0.4,0,0.2,1)";
  nextPage.style.transformOrigin = direction==="next" ? "left" : "right";
  nextPage.style.transform = "rotateY(0deg)";

  socket.emit("requestPlaneData", targetPlane);

  setTimeout(()=>{
    currentPlane = targetPlane;
    pageIndicator.textContent = `Page ${currentPlane+1} / ${totalPlanes}`;
    pageSlider.value = currentPlane;
    [currentPage.innerHTML, nextPage.innerHTML] = [nextPage.innerHTML, currentPage.innerHTML];
    [currentInputs, nextInputs] = [nextInputs, currentInputs];
    nextPage.style.transition = "none";
    nextPage.style.transform = direction==="next" ? "rotateY(-180deg)" : "rotateY(180deg)";
    isAnimating = false;
  }, 650);
}

// Prev/Next 버튼
prevBtn.addEventListener("click", ()=> flipToPage(currentPlane-1));
nextBtn.addEventListener("click", ()=> flipToPage(currentPlane+1));



// 드래그/스와이프 변수
let startX = 0;
let deltaX = 0;
let dragging = false;

// 드래그 시작
const handleStart = (x) => { if(isAnimating) return; startX=x; dragging=true; };
const handleMove = (x) => {
  if(!dragging || isAnimating) return;
  deltaX = x - startX;
  const percent = Math.max(-1, Math.min(1, deltaX / book.clientWidth));
  nextPage.style.transition = "none";
  nextPage.style.transformOrigin = percent < 0 ? "right" : "left";
  nextPage.style.transform = `rotateY(${percent * -180}deg)`;
};

// 드래그 끝
const handleEnd = () => {
  if(!dragging || isAnimating) return;
  dragging=false;
  if(deltaX < -100) startFlip("next");
  else if(deltaX > 100) startFlip("prev");
  else {
    // 원위치
    nextPage.style.transition = "transform 0.3s";
    nextPage.style.transform = deltaX < 0 ? "rotateY(-180deg)" : "rotateY(180deg)";
  }
  deltaX = 0;
};

// 페이지 넘기기
function startFlip(direction){
  if(isAnimating) return;
  isAnimating = true;
  const targetPlane = direction === "next" ? currentPlane + 1 : currentPlane - 1;
  if(targetPlane < 0 || targetPlane >= totalPlanes){ isAnimating=false; return; }

  nextPage.style.transition = "transform 0.6s cubic-bezier(0.4,0,0.2,1)";
  nextPage.style.transformOrigin = direction==="next" ? "left" : "right";
  nextPage.style.transform = "rotateY(0deg)";

  socket.emit("requestPlaneData", targetPlane);

  setTimeout(()=>{
    currentPlane = targetPlane;
    pageIndicator.textContent = `Page ${currentPlane + 1} / ${totalPlanes}`;
    [currentPage.innerHTML, nextPage.innerHTML] = [nextPage.innerHTML, currentPage.innerHTML];
    [currentInputs, nextInputs] = [nextInputs, currentInputs];
    nextPage.style.transition = "none";
    nextPage.style.transform = direction==="next" ? "rotateY(-180deg)" : "rotateY(180deg)";
    isAnimating = false;
  }, 650);
}

// 드래그 이벤트
book.addEventListener("mousedown", e => handleStart(e.clientX));
book.addEventListener("mousemove", e => handleMove(e.clientX));
book.addEventListener("mouseup", handleEnd);
book.addEventListener("mouseleave", handleEnd);

book.addEventListener("touchstart", e => handleStart(e.touches[0].clientX));
book.addEventListener("touchmove", e => handleMove(e.touches[0].clientX));
book.addEventListener("touchend", handleEnd);

// 초기 페이지
loadPlane(0);

</script>
</body>
</html> -->



<!-- ========================================================== -->
<!-- <!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>Bind the Air</title>

<link rel="stylesheet" href="font.css">
<link rel="stylesheet" href="index.css">
<link rel="stylesheet" href="index_detail.css">
<link rel="stylesheet" href="index_media.css">

<script src="/socket.io/socket.io.js"></script>

<style>
  body { margin: 0; padding: 0; background: #ccfbff; }
  #cover {
    display: none;
    position: absolute;
    padding: 20px;
  }
  #cover-back {
    display: none;
    position: absolute;
    padding: 20px;
  }
  #inputs { 
    position: relative;
    padding: 20px;
    display: grid; 
    grid-template-columns: 
    repeat(10, 1fr); 
    gap: 0;
    border: 4px solid white;
    width: 500px;
    height: 800px;
  }
  input { 
    margin: 0; 
    width: 100%;
    box-sizing: border-box; 
    color: gray;
    background: transparent;
    border: none;
    outline: none;
  }
  button { padding: 10px 20px; margin-right: 10px; }
  #pageIndicator { 
    position: absolute;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    display: inline-block;
    color: white;
  }
  #controls {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    margin-bottom: 20px;
  }
  #pageSlider {
    flex: 1;
  }
</style>
</head>
<body>
<div id="book">

  <div class="page" id="currentPage">
    <div id="inputs">
      <div id="cover">
        <h1>
          Bind the Air
        </h1>
        <p>
          Bind the Air is a continuation of Air–Drop, which was exhibited last May at the Open M Art Fair in Hangzhou. This volume was inspired by the abC team’s reflection: “If we could read the messages that each of us dropped into the air, Air–Drop could become a book we all create together.”

          In this project, the words we release into the air are gathered and bound into a book, binding us together across distances and borders. Visitors are invited to drift through a globe-shaped sky and leave messages wherever they wish. Each part of the sky is marked not by latitude or longitude, but by page numbers. By scanning the QR code on the wall, the sky’s scattered pages come together on their mobile devices, forming a book that can be flipped through and read.
          
          Throughout the exhibition, not only those in Shenzhen but people from all corners of the world are welcome to leave their messages. Together, as a global community, we bind the air into a shared book, turning borders into pages that connect us.
        </p>
      </div>
      <span id="pageIndicator">Page 1 / 64</span>
      <div id="cover-back">
        <p>
          Published By Halim Lee  
        </p>
      </div>

    </div>
  </div>
</div>

<div id="controls">
  <button id="prevBtn">Prev</button>
  <input type="range" id="pageSlider" min="0" max="65" value="0">
  <button id="nextBtn">Next</button>
  <button id="printBtn">Print</button>
</div>

<script>
const socket = io();

const totalPlanes = 66; // 0~65
const inputsCount = 180;
let currentPlane = 0;

const coverContainer = document.getElementById("cover");
const backcoverContainer = document.getElementById("cover-back");
const inputsContainer = document.getElementById("inputs");
const pageIndicator = document.getElementById("pageIndicator");
const prevBtn = document.getElementById("prevBtn");
const nextBtn = document.getElementById("nextBtn");
const pageSlider = document.getElementById("pageSlider");

// input 생성
const inputElements = [];
for (let i = 0; i < inputsCount; i++) {
  const input = document.createElement("input");
  input.type = "text"; 
  input.maxLength = 1;
  input.dataset.index = i;
  inputsContainer.appendChild(input);
  inputElements.push(input);

  input.addEventListener("input", (e) => {
    const index = parseInt(e.target.dataset.index);
    const value = e.target.value;

    // Plane JSON 페이지일 때만 서버 전송
    if (currentPlane >= 1 && currentPlane <= 64) {
      socket.emit("inputChange", {
        planeId: currentPlane,
        inputIndex: index,
        value
      });
    }
  });
}

// 페이지 로드
function loadPlane(planeId) {
  if (planeId < 0) planeId = 0;
  if (planeId >= totalPlanes) planeId = totalPlanes -1;

  currentPlane = planeId;
  pageIndicator.textContent = `Page ${currentPlane + 1} / ${totalPlanes}`;
  pageSlider.value = currentPlane;

  // 표지와 뒷표지 처리
  if (currentPlane === 0) {
    // 표지
    coverContainer.style.display = "block"; 
    backcoverContainer.style.display = "none"; 
    inputElements.forEach(input => input.style.display = "none");
  } else if (currentPlane === totalPlanes - 1) {
    // 뒷표지
    coverContainer.style.display = "none"; 
    backcoverContainer.style.display = "block"; 
    inputElements.forEach(input => input.style.display = "none");
  } else {
    // Plane JSON 페이지
    coverContainer.style.display = "none"; 
    backcoverContainer.style.display = "none"; 
    inputElements.forEach(input => input.style.display = "block");

    socket.emit("requestPlaneData", currentPlane);
  }
}


// 서버에서 데이터 수신 (페이지 로딩)
socket.on("loadPlaneData", ({ planeId, data }) => {
  if (planeId !== currentPlane) return;
  for (let i = 0; i < inputsCount; i++) {
    inputElements[i].value = data[`input${i}`] || '';
  }
});

// 다른 브라우저에서 데이터 변경 시 실시간 반영
socket.on("updateInput", ({ planeId, inputIndex, value }) => {
  if (planeId === currentPlane) {
    const idx = parseInt(inputIndex);
    const input = inputElements[idx];
    if(input) input.value = value || '';
  }
});

// Prev/Next 버튼
prevBtn.addEventListener("click", () => loadPlane(currentPlane - 1));
nextBtn.addEventListener("click", () => loadPlane(currentPlane + 1));

// 슬라이더 이벤트
pageSlider.addEventListener("input", (e) => {
  loadPlane(parseInt(e.target.value));
});

// 초기 페이지
loadPlane(0);

</script>
</body>
</html> -->
<!-- ========================================================== -->

<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>Bind the Air</title>

<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200&icon_names=arrow_back_ios_new,arrow_forward_ios" />

<link rel="stylesheet" href="font.css">
<!-- <link rel="stylesheet" href="index.css">
<link rel="stylesheet" href="index_detail.css">
<link rel="stylesheet" href="index_media.css"> -->

<script src="/socket.io/socket.io.js"></script>

<!-- jsPDF & html2canvas 추가 -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<style>
  body { margin: 0; padding: 0; background: #ccfbff; }
  #cover {
    display: none;
    position: absolute;
    padding: 20px;
  }
  #cover-back {
    display: none;
    position: absolute;
    padding: 20px;
  }
  .page {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100svh;
  }
  
  #inputs { 
    position: relative;
    padding: 20px 20px 40px 20px;
    display: grid; 
    grid-template-columns: 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr;
    grid-template-rows: 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr;
    gap: 0;
    border: 4px solid white;
    width: 240px;
    height: 400px;
    overflow-y: auto;
    overflow-x: hidden;
  }

  input { 
    margin: 0; 
    width: 16px;
    height: 28px;
    box-sizing: border-box; 
    text-transform: uppercase;
    color: black;
    font-family: 'FKGroteskMonoTrial-Regular', 'Noto Sans KR', 'Noto Sans SC', sans-serif;
    background: rgba(255, 255, 255, 0.2);
    border: 1px solid black;
    /* border: none; */
    outline: none;
    font-size: 16px;
    text-align: center;
    -webkit-text-fill-color: black;
  }
  button { 
    border: none;
    background: none;
    padding: 10px;
  }
  #pageIndicator { 
    position: absolute;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    display: inline-block;
    color: white;
  }
  #controls {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    margin-bottom: 20px;
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    z-index: 2;
  }
  #pageSlider {
    flex: 1;
  }
</style>
</head>
<body>
<div id="book">

  <div class="page" id="currentPage">
    <div id="inputs">
      <div id="cover">
        <h1>
          Bind the Air
        </h1>
        <p>
          Bind the Air is a continuation of Air–Drop, which was exhibited last May at the Open M Art Fair in Hangzhou. This volume was inspired by the abC team’s reflection: “If we could read the messages that each of us dropped into the air, Air–Drop could become a book we all create together.”

          In this project, the words we release into the air are gathered and bound into a book, binding us together across distances and borders. Visitors are invited to drift through a globe-shaped sky and leave messages wherever they wish. Each part of the sky is marked not by latitude or longitude, but by page numbers. By scanning the QR code on the wall, the sky’s scattered pages come together on their mobile devices, forming a book that can be flipped through and read.
          
          Throughout the exhibition, not only those in Shenzhen but people from all corners of the world are welcome to leave their messages. Together, as a global community, we bind the air into a shared book, turning borders into pages that connect us.
        </p>
      </div>
      <span id="pageIndicator">Page 1 / 64</span>
      <div id="cover-back">
        <p>
          Published By Halim Lee  
        </p>
      </div>

    </div>
  </div>
</div>


<button style="position: fixed; top: 5px; right: 10px;" id="saveBtn">PDF downlaod</button>

<div id="controls">
  <button id="prevBtn"><span class="material-symbols-outlined">arrow_back_ios_new</span></button>
  <input type="range" id="pageSlider" min="0" max="65" value="0">
  <button id="nextBtn"><span class="material-symbols-outlined">arrow_forward_ios</span></button>
</div>


<script>
const socket = io();

const totalPages = 66; // 0~65
const inputsCount = 180;
let currentPage = 0;

const coverContainer = document.getElementById("cover");
const backcoverContainer = document.getElementById("cover-back");
const inputsContainer = document.getElementById("inputs");
const pageIndicator = document.getElementById("pageIndicator");
const prevBtn = document.getElementById("prevBtn");
const nextBtn = document.getElementById("nextBtn");
const pageSlider = document.getElementById("pageSlider");

// input 생성
const inputElements = [];
for (let i = 0; i < inputsCount; i++) {
  const input = document.createElement("input");
  input.type = "text"; 
  input.maxLength = 1;
  input.dataset.index = i;
  inputsContainer.appendChild(input);
  inputElements.push(input);

  input.addEventListener("input", (e) => {
    const index = parseInt(e.target.dataset.index);
    const value = e.target.value;

    // 페이지 JSON 처리: 표지/뒷표지 제외
    if (currentPage >= 1 && currentPage <= totalPages - 2) {
      socket.emit("inputChange", {
        pageId: currentPage,
        inputIndex: index,
        value
      });
    }
  });
}

// 페이지 로드
function loadPage(pageId) {
  if (pageId < 0) pageId = 0;
  if (pageId >= totalPages) pageId = totalPages -1;

  currentPage = pageId;

  // 페이지 번호 표시 (표지/뒷표지 제외)
  if (currentPage === 0 || currentPage === totalPages - 1) {
    pageIndicator.style.display = "none";
  } else {
    pageIndicator.style.display = "inline-block";
    pageIndicator.textContent = `${currentPage}`;
    // pageIndicator.textContent = `Page ${currentPage} / ${totalPages}`;
  }

  pageSlider.value = currentPage;

  // 표지/뒷표지 처리
  if (currentPage === 0) {
    coverContainer.style.display = "block"; 
    backcoverContainer.style.display = "none"; 
    inputElements.forEach(input => input.style.display = "none");
  } else if (currentPage === totalPages - 1) {
    coverContainer.style.display = "none"; 
    backcoverContainer.style.display = "block"; 
    inputElements.forEach(input => input.style.display = "none");
  } else {
    coverContainer.style.display = "none"; 
    backcoverContainer.style.display = "none"; 
    inputElements.forEach(input => input.style.display = "block");

    // 서버에서 페이지 데이터 요청
    socket.emit("requestPlaneData", currentPage);
  }
}

// 서버에서 페이지 데이터 수신
socket.on("loadPlaneData", ({ pageId, data }) => {
  if (pageId !== currentPage) return;
  for (let i = 0; i < inputsCount; i++) {
    inputElements[i].value = data[`input${i}`] || '';
  }
});

// 다른 브라우저에서 데이터 변경 시 실시간 반영
socket.on("updateInput", ({ pageId, inputIndex, value }) => {
  if (pageId === currentPage) {
    const idx = parseInt(inputIndex);
    const input = inputElements[idx];
    if(input) input.value = value || '';
  }
});

// Prev/Next 버튼
prevBtn.addEventListener("click", () => loadPage(currentPage - 1));
nextBtn.addEventListener("click", () => loadPage(currentPage + 1));

// 슬라이더 이벤트
pageSlider.addEventListener("input", (e) => {
  loadPage(parseInt(e.target.value));
});

// 초기 페이지
loadPage(0);
</script>

<script>
const saveBtn = document.getElementById("saveBtn");
const totalBodyPages = 64; // JSON 페이지 수

// 표지 내용
const coverText = `
Bind the Air

Bind the Air is a continuation of Air–Drop, which was exhibited last May at the Open M Art Fair in Hangzhou. This volume was inspired by the abC team’s reflection: “If we could read the messages that each of us dropped into the air, Air–Drop could become a book we all create together.”

In this project, the words we release into the air are gathered and bound into a book, binding us together across distances and borders. Visitors are invited to drift through a globe-shaped sky and leave messages wherever they wish. Each part of the sky is marked not by latitude or longitude, but by page numbers. By scanning the QR code on the wall, the sky’s scattered pages come together on their mobile devices, forming a book that can be flipped through and read.

Throughout the exhibition, not only those in Shenzhen but people from all corners of the world are welcome to leave their messages. Together, as a global community, we bind the air into a shared book, turning borders into pages that connect us.
`;

// 뒷표지 내용
const backCoverText = `
Published by Halim Lee
`;

// JSON 파일 불러오기
async function loadPageJSON(pageNumber) {
  const res = await fetch(`pages/page_${pageNumber}.json`);
  if (!res.ok) {
    console.error(`Failed to load page_${pageNumber}.json`);
    return {};
  }
  return await res.json();
}

// PDF 생성
async function savePDFwithCover() {
  const { jsPDF } = window.jspdf;
  // const pdf = new jsPDF("p", "pt", "a4"); // 포트레이트, pt 단위, A4
  const pdf = new jsPDF("p", "pt", "a6");
  const cols = 10;
  const cellWidth = 15; 
  const cellHeight = 15;
  const startX = 20;  // 좌측 여백
  const startY = 40;  // 상단 여백
  // const cellWidth = 25;
  // const cellHeight = 25;
  // const startX = 40;
  // const startY = 60;

  // 1. 표지
  pdf.setFontSize(14);
  const coverLines = coverText.split("\n").filter(line => line.trim() !== "");
  coverLines.forEach((line, index) => {
    pdf.text(line, startX, startY + index * 18);
  });

  // 2. JSON 페이지들
  for (let page = 1; page <= totalBodyPages; page++) {
    pdf.addPage();
    const data = await loadPageJSON(page);

    let i = 0;
    for (let key in data) {
      const value = data[key] || "";
      const x = startX + (i % cols) * cellWidth;
      const y = startY + Math.floor(i / cols) * cellHeight;
      pdf.text(value, x, y);
      i++;
      if (i >= inputsCount) break;
    }

    // 페이지 번호 추가 (JSON 페이지들만)
    const pageNumber = page; // 1~64
    pdf.text(
      `${pageNumber}`,
      pdf.internal.pageSize.getWidth() / 2,
      pdf.internal.pageSize.getHeight() - 20,
      { align: "center" }
    );
  }

  // for (let page = 1; page <= totalBodyPages; page++) {
  //   pdf.addPage();
  //   const data = await loadPageJSON(page);

  //   let i = 0;
  //   for (let key in data) {
  //     const value = data[key] || "";
  //     const x = startX + (i % cols) * cellWidth;
  //     const y = startY + Math.floor(i / cols) * cellHeight;
  //     pdf.text(value, x, y);
  //     i++;
  //     if (i >= inputsCount) break;
  //   }
  // }

  // 3. 뒷표지
  pdf.addPage();
  const backLines = backCoverText.split("\n").filter(line => line.trim() !== "");
  backLines.forEach((line, index) => {
    pdf.text(line, startX, startY + index * 18);
  });

  // 저장
  pdf.save("BindTheAir.pdf");
}

// 버튼 이벤트
saveBtn.addEventListener("click", async () => {
  saveBtn.disabled = true;
  saveBtn.textContent = "Processing...";
  await savePDFwithCover();
  saveBtn.disabled = false;
  saveBtn.textContent = "Save";
});
</script>


<!-- <script>
const saveBtn = document.getElementById("saveBtn");

saveBtn.addEventListener("click", async () => {
  try {
    // #inputs 영역 캡처
    const canvas = await html2canvas(inputsContainer, {
      backgroundColor: null, // 투명 배경 원하면 null
      scale: 2 // 해상도 조정
    });
    
    // PNG 데이터 생성
    const imgData = canvas.toDataURL("image/png");

    // 다운로드 링크 생성
    const link = document.createElement("a");
    link.href = imgData;
    link.download = `page_${currentPage}.png`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    alert(`Page ${currentPage} PNG 저장 완료!`);
  } catch (err) {
    console.error("PNG 저장 실패", err);
  }
});
</script> -->

</body>
</html>